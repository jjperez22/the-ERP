<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Visual Report Designer</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: #f5f6fa;
            color: #333;
            height: 100vh;
            overflow: hidden;
        }
        
        /* Main Designer Container */
        .report-designer {
            display: flex;
            height: 100vh;
            background: white;
        }
        
        /* Header Bar */
        .designer-header {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 64px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            display: flex;
            align-items: center;
            padding: 0 24px;
            z-index: 1000;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }
        
        .header-left {
            display: flex;
            align-items: center;
            gap: 16px;
            flex: 1;
        }
        
        .designer-logo {
            font-size: 24px;
        }
        
        .designer-title {
            font-size: 18px;
            font-weight: 600;
        }
        
        .template-name {
            background: rgba(255,255,255,0.2);
            padding: 6px 12px;
            border-radius: 16px;
            font-size: 14px;
            margin-left: 16px;
        }
        
        .header-actions {
            display: flex;
            gap: 12px;
            align-items: center;
        }
        
        .header-btn {
            padding: 8px 16px;
            border: 2px solid rgba(255,255,255,0.3);
            border-radius: 20px;
            background: transparent;
            color: white;
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .header-btn:hover {
            background: rgba(255,255,255,0.2);
            border-color: rgba(255,255,255,0.5);
        }
        
        .header-btn.primary {
            background: rgba(255,255,255,0.2);
            border-color: rgba(255,255,255,0.5);
        }
        
        .header-btn.primary:hover {
            background: rgba(255,255,255,0.3);
        }
        
        .header-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        .header-btn:disabled:hover {
            background: transparent;
            border-color: rgba(255,255,255,0.3);
        }
        
        .header-separator {
            width: 2px;
            height: 32px;
            background: rgba(255,255,255,0.3);
            margin: 0 8px;
        }
        
        /* Left Sidebar - Component Palette */
        .component-palette {
            width: 280px;
            background: #f8f9fa;
            border-right: 1px solid #e9ecef;
            margin-top: 64px;
            height: calc(100vh - 64px);
            overflow-y: auto;
        }
        
        .palette-section {
            padding: 20px 16px;
            border-bottom: 1px solid #e9ecef;
        }
        
        .palette-title {
            font-size: 14px;
            font-weight: 600;
            color: #495057;
            margin-bottom: 16px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        .component-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 12px;
        }
        
        .component-item {
            background: white;
            border: 2px solid #e9ecef;
            border-radius: 8px;
            padding: 16px 12px;
            text-align: center;
            cursor: grab;
            transition: all 0.2s ease;
            user-select: none;
        }
        
        .component-item:hover {
            border-color: #007bff;
            box-shadow: 0 2px 8px rgba(0,123,255,0.15);
        }
        
        .component-item:active {
            cursor: grabbing;
            transform: scale(0.98);
        }
        
        .component-icon {
            font-size: 24px;
            margin-bottom: 8px;
            display: block;
        }
        
        .component-name {
            font-size: 12px;
            font-weight: 500;
            color: #495057;
        }
        
        /* Main Design Canvas Area */
        .canvas-area {
            flex: 1;
            display: flex;
            flex-direction: column;
            margin-top: 64px;
            height: calc(100vh - 64px);
        }
        
        /* Canvas Toolbar */
        .canvas-toolbar {
            background: white;
            border-bottom: 1px solid #e9ecef;
            padding: 12px 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            min-height: 56px;
        }
        
        .toolbar-left {
            display: flex;
            align-items: center;
            gap: 16px;
        }
        
        .zoom-controls {
            display: flex;
            align-items: center;
            gap: 8px;
            background: #f8f9fa;
            border: 1px solid #e9ecef;
            border-radius: 6px;
            padding: 4px;
        }
        
        .zoom-btn {
            width: 32px;
            height: 32px;
            border: none;
            background: transparent;
            border-radius: 4px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 16px;
            transition: background-color 0.15s ease;
        }
        
        .zoom-btn:hover {
            background: #e9ecef;
        }
        
        .zoom-display {
            padding: 0 12px;
            font-size: 14px;
            font-weight: 500;
            color: #495057;
        }
        
        .toolbar-right {
            display: flex;
            gap: 12px;
            align-items: center;
        }
        
        .view-mode-toggle {
            display: flex;
            background: #f8f9fa;
            border: 1px solid #e9ecef;
            border-radius: 6px;
            overflow: hidden;
        }
        
        .view-mode-btn {
            padding: 8px 12px;
            border: none;
            background: transparent;
            cursor: pointer;
            font-size: 13px;
            color: #6c757d;
            transition: all 0.15s ease;
        }
        
        .view-mode-btn.active {
            background: #007bff;
            color: white;
        }
        
        /* Canvas Container */
        .canvas-container {
            flex: 1;
            background: #f5f6fa;
            position: relative;
            overflow: auto;
            padding: 40px;
        }
        
        /* Report Canvas */
        .report-canvas {
            background: white;
            border: 1px solid #dee2e6;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
            margin: 0 auto;
            position: relative;
            min-height: 800px;
        }
        
        /* A4 Paper Size */
        .canvas-a4 {
            width: 210mm;
            height: 297mm;
        }
        
        /* Letter Paper Size */
        .canvas-letter {
            width: 8.5in;
            height: 11in;
        }
        
        /* Canvas Grid */
        .canvas-grid {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            pointer-events: none;
            opacity: 0.3;
        }
        
        .canvas-grid.show-grid {
            background-image: 
                linear-gradient(to right, #e9ecef 1px, transparent 1px),
                linear-gradient(to bottom, #e9ecef 1px, transparent 1px);
            background-size: 20px 20px;
        }
        
        /* Drop Zone */
        .drop-zone {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            border: 2px dashed transparent;
            transition: all 0.2s ease;
        }
        
        .drop-zone.drag-over {
            border-color: #007bff;
            background: rgba(0,123,255,0.05);
        }
        
        /* Right Sidebar - Properties Panel */
        .properties-panel {
            width: 300px;
            background: #f8f9fa;
            border-left: 1px solid #e9ecef;
            margin-top: 64px;
            height: calc(100vh - 64px);
            overflow-y: auto;
        }
        
        .properties-header {
            padding: 20px;
            border-bottom: 1px solid #e9ecef;
            background: white;
        }
        
        .properties-title {
            font-size: 16px;
            font-weight: 600;
            color: #333;
            margin-bottom: 8px;
        }
        
        .properties-subtitle {
            font-size: 13px;
            color: #6c757d;
        }
        
        .properties-content {
            padding: 20px;
        }
        
        .property-group {
            margin-bottom: 24px;
        }
        
        .property-group-title {
            font-size: 14px;
            font-weight: 600;
            color: #495057;
            margin-bottom: 12px;
            padding-bottom: 6px;
            border-bottom: 1px solid #e9ecef;
        }
        
        .property-item {
            margin-bottom: 12px;
        }
        
        .property-label {
            display: block;
            font-size: 13px;
            font-weight: 500;
            color: #555;
            margin-bottom: 6px;
        }
        
        .property-input {
            width: 100%;
            padding: 8px 10px;
            border: 2px solid #e9ecef;
            border-radius: 4px;
            font-size: 14px;
            transition: border-color 0.15s ease;
        }
        
        .property-input:focus {
            outline: none;
            border-color: #007bff;
        }
        
        .property-select {
            appearance: none;
            background-image: url('data:image/svg+xml;charset=US-ASCII,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 4 5"><path fill="%23666" d="M2 0L0 2h4zm0 5L0 3h4z"/></svg>');
            background-repeat: no-repeat;
            background-position: right 8px center;
            background-size: 12px;
            padding-right: 28px;
        }
        
        /* Property Panel Extensions */
        .property-row {
            display: flex;
            gap: 12px;
        }
        
        .property-half {
            flex: 1;
        }
        
        .color-input-wrapper {
            display: flex;
            gap: 8px;
            align-items: center;
        }
        
        .color-input {
            width: 60px !important;
            height: 40px;
            padding: 4px;
            cursor: pointer;
            border-radius: 6px;
        }
        
        .color-text {
            flex: 1;
            font-family: 'Courier New', monospace;
            font-size: 13px;
        }
        
        .property-input[type="checkbox"] {
            width: auto;
            margin-right: 8px;
        }
        
        .property-label:has(input[type="checkbox"]) {
            display: flex;
            align-items: center;
            cursor: pointer;
        }
        
        .property-group[style*="display: none"] {
            animation: fadeOut 0.2s ease;
        }
        
        .property-group:not([style*="display: none"]) {
            animation: fadeIn 0.2s ease;
        }
        
        /* Empty State */
        .canvas-empty-state {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            color: #6c757d;
            pointer-events: none;
        }
        
        .empty-icon {
            font-size: 64px;
            margin-bottom: 16px;
        }
        
        .empty-title {
            font-size: 18px;
            font-weight: 600;
            margin-bottom: 8px;
            color: #495057;
        }
        
        .empty-description {
            font-size: 14px;
            line-height: 1.4;
            max-width: 300px;
        }
        
        /* Status Bar */
        .status-bar {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            height: 32px;
            background: #f8f9fa;
            border-top: 1px solid #e9ecef;
            display: flex;
            align-items: center;
            padding: 0 20px;
            font-size: 12px;
            color: #6c757d;
            z-index: 100;
        }
        
        .status-item {
            margin-right: 20px;
        }
        
        .status-item:last-child {
            margin-left: auto;
            margin-right: 0;
        }
        
        /* Context Menu */
        .context-menu {
            position: absolute;
            background: white;
            border: 1px solid #e9ecef;
            border-radius: 6px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            padding: 4px 0;
            min-width: 160px;
            z-index: 2000;
            display: none;
        }
        
        .context-menu-item {
            padding: 8px 16px;
            cursor: pointer;
            font-size: 14px;
            color: #333;
            transition: background-color 0.15s ease;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .context-menu-item:hover {
            background-color: #f8f9fa;
        }
        
        .context-menu-item.disabled {
            color: #6c757d;
            cursor: not-allowed;
        }
        
        .context-menu-item.disabled:hover {
            background-color: transparent;
        }
        
        .context-menu-separator {
            height: 1px;
            background-color: #e9ecef;
            margin: 4px 0;
        }
        
        /* Selection Handles */
        .selection-handles {
            position: absolute;
            pointer-events: none;
            z-index: 1001;
        }
        
        .selection-handle {
            position: absolute;
            width: 8px;
            height: 8px;
            background: #007bff;
            border: 1px solid white;
            border-radius: 50%;
            pointer-events: all;
            cursor: pointer;
        }
        
        .selection-handle.nw { top: -4px; left: -4px; cursor: nw-resize; }
        .selection-handle.ne { top: -4px; right: -4px; cursor: ne-resize; }
        .selection-handle.sw { bottom: -4px; left: -4px; cursor: sw-resize; }
        .selection-handle.se { bottom: -4px; right: -4px; cursor: se-resize; }
        .selection-handle.n { top: -4px; left: 50%; margin-left: -4px; cursor: n-resize; }
        .selection-handle.s { bottom: -4px; left: 50%; margin-left: -4px; cursor: s-resize; }
        .selection-handle.w { top: 50%; left: -4px; margin-top: -4px; cursor: w-resize; }
        .selection-handle.e { top: 50%; right: -4px; margin-top: -4px; cursor: e-resize; }
        
        /* Image Upload Styles */
        .image-drop-zone {
            transition: all 0.3s ease;
        }
        
        .image-drop-zone.drag-over {
            border: 2px dashed #007bff !important;
            background-color: rgba(0, 123, 255, 0.1) !important;
        }
        
        .image-drop-zone.drag-over .image-placeholder {
            transform: scale(1.05);
            opacity: 0.8;
        }
        
        .image-upload-feedback {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 123, 255, 0.9);
            color: white;
            padding: 8px 16px;
            border-radius: 20px;
            font-size: 12px;
            font-weight: 500;
            pointer-events: none;
            z-index: 1002;
            opacity: 0;
            transition: opacity 0.3s ease;
        }
        
        .image-drop-zone.drag-over .image-upload-feedback {
            opacity: 1;
        }
        
        /* Selection Box for Drag-to-Select */
        .selection-box {
            position: absolute;
            border: 2px dashed #007bff;
            background: rgba(0, 123, 255, 0.1);
            border-radius: 3px;
            pointer-events: none;
            z-index: 1500;
            opacity: 0;
            transition: opacity 0.1s ease;
        }
        
        .selection-box.active {
            opacity: 1;
        }
        
        /* Prevent text selection during drag-to-select */
        .canvas-container.selecting {
            user-select: none;
            cursor: crosshair;
        }
        
        .canvas-container.selecting * {
            pointer-events: none;
        }
        
        /* Responsive Design */
        @media (max-width: 1200px) {
            .component-palette {
                width: 240px;
            }
            
            .properties-panel {
                width: 260px;
            }
        }
        
        @media (max-width: 768px) {
            .report-designer {
                flex-direction: column;
            }
            
            .component-palette,
            .properties-panel {
                width: 100%;
                height: auto;
                max-height: 200px;
                margin-top: 0;
            }
            
            .canvas-area {
                margin-top: 0;
                height: auto;
                flex: 1;
            }
            
            .canvas-container {
                padding: 20px;
            }
            
            .report-canvas {
                width: 100%;
                min-width: 300px;
            }
        }
    </style>
</head>
<body>
    <div class="report-designer">
        <!-- Header Bar -->
        <div class="designer-header">
            <div class="header-left">
                <div class="designer-logo">🎨</div>
                <div class="designer-title">Visual Report Designer</div>
                <div class="template-name">Project Status Report</div>
            </div>
            <div class="header-actions">
                <button class="header-btn" id="undo-btn" title="Undo (Ctrl+Z)" disabled>↶ Undo</button>
                <button class="header-btn" id="redo-btn" title="Redo (Ctrl+Y)" disabled>↷ Redo</button>
                <div class="header-separator"></div>
                <button class="header-btn">💾 Save</button>
                <button class="header-btn">👁️ Preview</button>
                <button class="header-btn primary">🚀 Publish</button>
                <button class="header-btn">❌ Close</button>
            </div>
        </div>
        
        <!-- Component Palette (Left Sidebar) -->
        <div class="component-palette">
            <div class="palette-section">
                <div class="palette-title">Layout Components</div>
                <div class="component-grid">
                    <div class="component-item" data-component="header">
                        <span class="component-icon">📋</span>
                        <span class="component-name">Header</span>
                    </div>
                    <div class="component-item" data-component="text">
                        <span class="component-icon">📝</span>
                        <span class="component-name">Text Block</span>
                    </div>
                    <div class="component-item" data-component="table">
                        <span class="component-icon">📊</span>
                        <span class="component-name">Data Table</span>
                    </div>
                    <div class="component-item" data-component="image">
                        <span class="component-icon">🖼️</span>
                        <span class="component-name">Image</span>
                    </div>
                </div>
            </div>
            
            <div class="palette-section">
                <div class="palette-title">Chart Components</div>
                <div class="component-grid">
                    <div class="component-item" data-component="bar-chart">
                        <span class="component-icon">📊</span>
                        <span class="component-name">Bar Chart</span>
                    </div>
                    <div class="component-item" data-component="line-chart">
                        <span class="component-icon">📈</span>
                        <span class="component-name">Line Chart</span>
                    </div>
                    <div class="component-item" data-component="pie-chart">
                        <span class="component-icon">🥧</span>
                        <span class="component-name">Pie Chart</span>
                    </div>
                    <div class="component-item" data-component="gauge">
                        <span class="component-icon">⏲️</span>
                        <span class="component-name">Gauge</span>
                    </div>
                </div>
            </div>
            
            <div class="palette-section">
                <div class="palette-title">Data Components</div>
                <div class="component-grid">
                    <div class="component-item" data-component="number">
                        <span class="component-icon">🔢</span>
                        <span class="component-name">Number</span>
                    </div>
                    <div class="component-item" data-component="progress">
                        <span class="component-icon">📊</span>
                        <span class="component-name">Progress</span>
                    </div>
                    <div class="component-item" data-component="metric">
                        <span class="component-icon">📈</span>
                        <span class="component-name">KPI Metric</span>
                    </div>
                    <div class="component-item" data-component="divider">
                        <span class="component-icon">➖</span>
                        <span class="component-name">Divider</span>
                    </div>
                </div>
            </div>
        </div>
        
        <!-- Main Canvas Area -->
        <div class="canvas-area">
            <!-- Canvas Toolbar -->
            <div class="canvas-toolbar">
                <div class="toolbar-left">
                    <div class="zoom-controls">
                        <button class="zoom-btn">➖</button>
                        <div class="zoom-display">100%</div>
                        <button class="zoom-btn">➕</button>
                    </div>
                </div>
                
                <div class="toolbar-right">
                    <div class="view-mode-toggle">
                        <button class="view-mode-btn active">Design</button>
                        <button class="view-mode-btn">Preview</button>
                    </div>
                </div>
            </div>
            
            <!-- Canvas Container -->
            <div class="canvas-container">
                <div class="report-canvas canvas-a4">
                    <div class="canvas-grid show-grid"></div>
                    <div class="drop-zone"></div>
                    
                    <!-- Empty State -->
                    <div class="canvas-empty-state">
                        <div class="empty-icon">🎨</div>
                        <div class="empty-title">Start Building Your Report</div>
                        <div class="empty-description">
                            Drag components from the left panel onto this canvas to begin designing your report layout.
                        </div>
                    </div>
                </div>
            </div>
        </div>
        
        <!-- Properties Panel (Right Sidebar) -->
        <div class="properties-panel">
            <div class="properties-header">
                <div class="properties-title">Properties</div>
                <div class="properties-subtitle" id="properties-subtitle">Select an element to edit its properties</div>
            </div>
            
            <div class="properties-content" id="properties-content">
                <!-- Default Canvas Settings -->
                <div class="property-group" id="canvas-settings">
                    <div class="property-group-title">Canvas Settings</div>
                    
                    <div class="property-item">
                        <label class="property-label">Paper Size</label>
                        <select class="property-input property-select" id="paper-size-select">
                            <option value="a4">A4 (210 × 297 mm)</option>
                            <option value="letter">Letter (8.5 × 11 in)</option>
                            <option value="legal">Legal (8.5 × 14 in)</option>
                        </select>
                    </div>
                    
                    <div class="property-item">
                        <label class="property-label">Orientation</label>
                        <select class="property-input property-select" id="orientation-select">
                            <option value="portrait">Portrait</option>
                            <option value="landscape">Landscape</option>
                        </select>
                    </div>
                    
                    <div class="property-item">
                        <label class="property-label">Margin (mm)</label>
                        <input type="number" class="property-input" id="margin-input" value="20" min="0" max="50">
                    </div>
                </div>
                
                <div class="property-group" id="grid-settings">
                    <div class="property-group-title">Grid Settings</div>
                    
                    <div class="property-item">
                        <label class="property-label">
                            <input type="checkbox" id="show-grid-checkbox" checked> Show Grid
                        </label>
                    </div>
                    
                    <div class="property-item">
                        <label class="property-label">
                            <input type="checkbox" id="snap-grid-checkbox" checked> Snap to Grid
                        </label>
                    </div>
                    
                    <div class="property-item">
                        <label class="property-label">Grid Size (px)</label>
                        <input type="number" class="property-input" id="grid-size-input" value="20" min="5" max="50">
                    </div>
                </div>
                
                <!-- Dynamic Element Properties (hidden by default) -->
                <div class="property-group" id="element-properties" style="display: none;">
                    <div class="property-group-title" id="element-properties-title">Element Properties</div>
                    <div id="element-properties-content">
                        <!-- Dynamic content will be inserted here -->
                    </div>
                </div>
                
                <div class="property-group" id="position-properties" style="display: none;">
                    <div class="property-group-title">Position & Size</div>
                    <div class="property-row">
                        <div class="property-item property-half">
                            <label class="property-label">X Position</label>
                            <input type="number" class="property-input" id="element-x" min="0">
                        </div>
                        <div class="property-item property-half">
                            <label class="property-label">Y Position</label>
                            <input type="number" class="property-input" id="element-y" min="0">
                        </div>
                    </div>
                    <div class="property-row">
                        <div class="property-item property-half">
                            <label class="property-label">Width</label>
                            <input type="number" class="property-input" id="element-width" min="50">
                        </div>
                        <div class="property-item property-half">
                            <label class="property-label">Height</label>
                            <input type="number" class="property-input" id="element-height" min="20">
                        </div>
                    </div>
                </div>
                
                <div class="property-group" id="style-properties" style="display: none;">
                    <div class="property-group-title">Style</div>
                    <div class="property-item">
                        <label class="property-label">Background Color</label>
                        <div class="color-input-wrapper">
                            <input type="color" class="property-input color-input" id="element-bg-color" value="#ffffff">
                            <input type="text" class="property-input color-text" id="element-bg-color-text" value="#ffffff">
                        </div>
                    </div>
                    <div class="property-item">
                        <label class="property-label">Border Color</label>
                        <div class="color-input-wrapper">
                            <input type="color" class="property-input color-input" id="element-border-color" value="#transparent">
                            <input type="text" class="property-input color-text" id="element-border-color-text" value="transparent">
                        </div>
                    </div>
                    <div class="property-item">
                        <label class="property-label">Border Width (px)</label>
                        <input type="number" class="property-input" id="element-border-width" value="2" min="0" max="10">
                    </div>
                    <div class="property-item">
                        <label class="property-label">Border Radius (px)</label>
                        <input type="number" class="property-input" id="element-border-radius" value="4" min="0" max="50">
                    </div>
                    <div class="property-item">
                        <label class="property-label">Padding (px)</label>
                        <input type="number" class="property-input" id="element-padding" value="12" min="0" max="50">
                    </div>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Context Menu -->
    <div class="context-menu" id="context-menu">
        <div class="context-menu-item" data-action="copy">
            <span>📋</span> Copy
        </div>
        <div class="context-menu-item" data-action="paste">
            <span>📄</span> Paste
        </div>
        <div class="context-menu-item" data-action="duplicate">
            <span>📑</span> Duplicate
        </div>
        <div class="context-menu-separator"></div>
        <div class="context-menu-item" data-action="bring-to-front">
            <span>⬆️</span> Bring to Front
        </div>
        <div class="context-menu-item" data-action="send-to-back">
            <span>⬇️</span> Send to Back
        </div>
        <div class="context-menu-separator"></div>
        <div class="context-menu-item" data-action="delete">
            <span>🗑️</span> Delete
        </div>
    </div>
    
    <!-- Selection Handles -->
    <div class="selection-handles" id="selection-handles" style="display: none;">
        <div class="selection-handle nw"></div>
        <div class="selection-handle n"></div>
        <div class="selection-handle ne"></div>
        <div class="selection-handle w"></div>
        <div class="selection-handle e"></div>
        <div class="selection-handle sw"></div>
        <div class="selection-handle s"></div>
        <div class="selection-handle se"></div>
    </div>
    
    <!-- Selection Box for Drag-to-Select -->
    <div class="selection-box" id="selection-box" style="display: none;"></div>
    
    <!-- Status Bar -->
    <div class="status-bar">
        <span class="status-item">Elements: 0</span>
        <span class="status-item">Canvas: A4 Portrait</span>
        <span class="status-item">Grid: 20px</span>
        <span class="status-item">Ready</span>
    </div>
    
    <script>
        // Action History System for Undo/Redo Functionality
        class ActionHistory {
            constructor(maxHistorySize = 50) {
                this.undoStack = [];
                this.redoStack = [];
                this.maxHistorySize = maxHistorySize;
                this.isRecording = true;
                this.batchActions = [];
                this.isBatching = false;
            }
            
            // Execute and record an action
            executeAction(action) {
                if (!this.isRecording) return;
                
                try {
                    // Execute the action
                    action.execute();
                    
                    // Add to history
                    if (this.isBatching) {
                        this.batchActions.push(action);
                    } else {
                        this.addToHistory(action);
                    }
                    
                    // Clear redo stack since we performed a new action
                    this.redoStack = [];
                    
                    return true;
                } catch (error) {
                    console.error('Error executing action:', error);
                    return false;
                }
            }
            
            // Add action to undo stack
            addToHistory(action) {
                this.undoStack.push(action);
                
                // Limit history size
                if (this.undoStack.length > this.maxHistorySize) {
                    this.undoStack.shift();
                }
            }
            
            // Start batching actions
            startBatch() {
                this.isBatching = true;
                this.batchActions = [];
            }
            
            // End batching and create a batch action
            endBatch(batchName = 'Batch Operation') {
                if (!this.isBatching || this.batchActions.length === 0) {
                    this.isBatching = false;
                    return;
                }
                
                const batchAction = new BatchAction(this.batchActions.slice(), batchName);
                this.addToHistory(batchAction);
                
                this.isBatching = false;
                this.batchActions = [];
            }
            
            // Undo the last action
            undo() {
                if (this.undoStack.length === 0) {
                    return { success: false, message: 'Nothing to undo' };
                }
                
                const action = this.undoStack.pop();
                
                try {
                    this.isRecording = false;
                    action.undo();
                    this.isRecording = true;
                    
                    this.redoStack.push(action);
                    
                    return { 
                        success: true, 
                        message: `Undid: ${action.name}`,
                        action: action
                    };
                } catch (error) {
                    console.error('Error undoing action:', error);
                    this.undoStack.push(action); // Put it back
                    this.isRecording = true;
                    return { success: false, message: 'Failed to undo action' };
                }
            }
            
            // Redo the last undone action
            redo() {
                if (this.redoStack.length === 0) {
                    return { success: false, message: 'Nothing to redo' };
                }
                
                const action = this.redoStack.pop();
                
                try {
                    this.isRecording = false;
                    action.execute();
                    this.isRecording = true;
                    
                    this.undoStack.push(action);
                    
                    return { 
                        success: true, 
                        message: `Redid: ${action.name}`,
                        action: action
                    };
                } catch (error) {
                    console.error('Error redoing action:', error);
                    this.redoStack.push(action); // Put it back
                    this.isRecording = true;
                    return { success: false, message: 'Failed to redo action' };
                }
            }
            
            // Check if undo is available
            canUndo() {
                return this.undoStack.length > 0;
            }
            
            // Check if redo is available
            canRedo() {
                return this.redoStack.length > 0;
            }
            
            // Clear all history
            clear() {
                this.undoStack = [];
                this.redoStack = [];
            }
            
            // Get history status
            getStatus() {
                return {
                    undoCount: this.undoStack.length,
                    redoCount: this.redoStack.length,
                    canUndo: this.canUndo(),
                    canRedo: this.canRedo(),
                    lastAction: this.undoStack.length > 0 ? this.undoStack[this.undoStack.length - 1].name : null
                };
            }
        }
        
        // Base Action class
        class Action {
            constructor(name) {
                this.name = name;
                this.timestamp = Date.now();
            }
            
            execute() {
                throw new Error('execute() method must be implemented');
            }
            
            undo() {
                throw new Error('undo() method must be implemented');
            }
        }
        
        // Batch Action for grouping multiple actions
        class BatchAction extends Action {
            constructor(actions, name) {
                super(name);
                this.actions = actions;
            }
            
            execute() {
                for (const action of this.actions) {
                    action.execute();
                }
            }
            
            undo() {
                // Undo in reverse order
                for (let i = this.actions.length - 1; i >= 0; i--) {
                    this.actions[i].undo();
                }
            }
        }
        
        // Add Element Action
        class AddElementAction extends Action {
            constructor(element, canvas, designer) {
                super(`Add ${element.dataset.componentType}`);
                this.element = element;
                this.canvas = canvas;
                this.designer = designer;
            }
            
            execute() {
                if (!this.element.parentNode) {
                    this.canvas.appendChild(this.element);
                    this.designer.elementCount++;
                    this.designer.updateStatusBar();
                    
                    // Hide empty state
                    const emptyState = this.canvas.querySelector('.canvas-empty-state');
                    if (emptyState) {
                        emptyState.style.display = 'none';
                    }
                }
            }
            
            undo() {
                if (this.element.parentNode) {
                    // Deselect if this element is selected
                    if (this.designer.selectedElement === this.element) {
                        this.designer.deselectAllElements();
                    }
                    
                    this.element.remove();
                    this.designer.elementCount--;
                    this.designer.updateStatusBar();
                    
                    // Show empty state if no elements left
                    if (this.designer.elementCount === 0) {
                        const emptyState = this.canvas.querySelector('.canvas-empty-state');
                        if (emptyState) {
                            emptyState.style.display = 'block';
                        }
                    }
                }
            }
        }
        
        // Delete Element Action
        class DeleteElementAction extends Action {
            constructor(element, canvas, designer) {
                super(`Delete ${element.dataset.componentType}`);
                this.element = element;
                this.canvas = canvas;
                this.designer = designer;
                this.nextSibling = element.nextSibling;
            }
            
            execute() {
                if (this.element.parentNode) {
                    // Deselect if this element is selected
                    if (this.designer.selectedElement === this.element) {
                        this.designer.deselectAllElements();
                    }
                    
                    this.element.remove();
                    this.designer.elementCount--;
                    this.designer.updateStatusBar();
                    
                    // Show empty state if no elements left
                    if (this.designer.elementCount === 0) {
                        const emptyState = this.canvas.querySelector('.canvas-empty-state');
                        if (emptyState) {
                            emptyState.style.display = 'block';
                        }
                    }
                }
            }
            
            undo() {
                if (!this.element.parentNode) {
                    if (this.nextSibling && this.nextSibling.parentNode === this.canvas) {
                        this.canvas.insertBefore(this.element, this.nextSibling);
                    } else {
                        this.canvas.appendChild(this.element);
                    }
                    
                    this.designer.elementCount++;
                    this.designer.updateStatusBar();
                    
                    // Hide empty state
                    const emptyState = this.canvas.querySelector('.canvas-empty-state');
                    if (emptyState) {
                        emptyState.style.display = 'none';
                    }
                }
            }
        }
        
        // Move Element Action
        class MoveElementAction extends Action {
            constructor(element, oldPosition, newPosition) {
                super(`Move ${element.dataset.componentType}`);
                this.element = element;
                this.oldPosition = { ...oldPosition };
                this.newPosition = { ...newPosition };
            }
            
            execute() {
                this.element.style.left = this.newPosition.x + 'px';
                this.element.style.top = this.newPosition.y + 'px';
            }
            
            undo() {
                this.element.style.left = this.oldPosition.x + 'px';
                this.element.style.top = this.oldPosition.y + 'px';
            }
        }
        
        // Resize Element Action
        class ResizeElementAction extends Action {
            constructor(element, oldDimensions, newDimensions) {
                super(`Resize ${element.dataset.componentType}`);
                this.element = element;
                this.oldDimensions = { ...oldDimensions };
                this.newDimensions = { ...newDimensions };
            }
            
            execute() {
                this.element.style.left = this.newDimensions.x + 'px';
                this.element.style.top = this.newDimensions.y + 'px';
                this.element.style.width = this.newDimensions.width + 'px';
                this.element.style.height = this.newDimensions.height + 'px';
            }
            
            undo() {
                this.element.style.left = this.oldDimensions.x + 'px';
                this.element.style.top = this.oldDimensions.y + 'px';
                this.element.style.width = this.oldDimensions.width + 'px';
                this.element.style.height = this.oldDimensions.height + 'px';
            }
        }
        
        // Property Change Action
        class PropertyChangeAction extends Action {
            constructor(element, property, oldValue, newValue, designer) {
                super(`Change ${element.dataset.componentType} ${property}`);
                this.element = element;
                this.property = property;
                this.oldValue = oldValue;
                this.newValue = newValue;
                this.designer = designer;
            }
            
            execute() {
                this.applyPropertyValue(this.newValue);
            }
            
            undo() {
                this.applyPropertyValue(this.oldValue);
            }
            
            applyPropertyValue(value) {
                // Update element's dataset properties
                if (!this.element.dataset.properties) {
                    this.element.dataset.properties = '{}';
                }
                
                const currentProperties = JSON.parse(this.element.dataset.properties);
                currentProperties[this.property] = value;
                this.element.dataset.properties = JSON.stringify(currentProperties);
                
                // Apply visual changes through designer
                if (this.designer.selectedElement === this.element) {
                    this.designer.applyPropertyChange(this.property, value, this.element.dataset.componentType);
                }
            }
        }
        
        // Text Edit Action
        class TextEditAction extends Action {
            constructor(element, textElement, oldText, newText, designer) {
                super(`Edit ${element.dataset.componentType} text`);
                this.element = element;
                this.textElement = textElement;
                this.oldText = oldText;
                this.newText = newText;
                this.designer = designer;
            }
            
            execute() {
                this.textElement.textContent = this.newText;
                this.updateStoredProperty('content', this.newText);
            }
            
            undo() {
                this.textElement.textContent = this.oldText;
                this.updateStoredProperty('content', this.oldText);
            }
            
            updateStoredProperty(property, value) {
                if (!this.element.dataset.properties) {
                    this.element.dataset.properties = '{}';
                }
                const currentProperties = JSON.parse(this.element.dataset.properties);
                currentProperties[property] = value;
                this.element.dataset.properties = JSON.stringify(currentProperties);
            }
        }
        
        // Image Upload Action
        class ImageUploadAction extends Action {
            constructor(element, oldImageData, newImageData, designer) {
                super(`Upload image to ${element.dataset.componentType}`);
                this.element = element;
                this.oldImageData = oldImageData;
                this.newImageData = newImageData;
                this.designer = designer;
            }
            
            execute() {
                if (this.newImageData) {
                    this.designer.displayImageInElement(this.element, this.newImageData.src, this.newImageData.filename);
                    this.designer.storeImageData(this.element, this.newImageData);
                } else {
                    this.restoreImagePlaceholder();
                }
            }
            
            undo() {
                if (this.oldImageData) {
                    this.designer.displayImageInElement(this.element, this.oldImageData.src, this.oldImageData.filename);
                    this.designer.storeImageData(this.element, this.oldImageData);
                } else {
                    this.restoreImagePlaceholder();
                }
            }
            
            restoreImagePlaceholder() {
                const imageContainer = this.element.querySelector('.image-drop-zone');
                if (imageContainer) {
                    imageContainer.innerHTML = `
                        <div style="border: 2px dashed #ddd; padding: 20px; border-radius: 4px; text-align: center;" class="image-placeholder">
                            <div style="font-size: 24px; margin-bottom: 4px;">🖼️</div>
                            <div style="font-size: 12px; color: #666;">Drop image or click to upload</div>
                        </div>
                        <div class="image-upload-feedback">📁 Drop image here</div>
                    `;
                    this.designer.setupImageUpload(this.element);
                }
            }
        }
        
        // Visual Report Designer - Basic JavaScript Functionality
        class ReportDesigner {
            constructor() {
                this.currentZoom = 100;
                this.minZoom = 25;
                this.maxZoom = 200;
                this.zoomStep = 25;
                this.currentView = 'design';
                this.showGrid = true;
                this.snapToGrid = true;
                this.gridSize = 20;
                this.elementCount = 0;
                this.paperSize = 'a4';
                this.orientation = 'portrait';
                this.margin = 20;
                
                // Element selection state
                this.selectedElement = null;
                this.selectedElementData = null;
                this.selectedElements = new Set(); // For multi-select
                this.isMultiSelectMode = false;
                
                // Selection box for drag-to-select
                this.selectionBox = null;
                this.isSelectionBoxActive = false;
                this.selectionBoxStart = { x: 0, y: 0 };
                this.selectionBoxEnd = { x: 0, y: 0 };
                
                // Element property templates
                this.elementPropertyTemplates = this.initializePropertyTemplates();
                
                // Action history system for undo/redo
                this.actionHistory = new ActionHistory();
                this.clipboard = null;
                
                this.init();
            }
            
            init() {
                this.bindEvents();
                this.updateZoomDisplay();
                this.updateStatusBar();
                this.updateUndoRedoButtons();
            }
            
            bindEvents() {
                this.setupDragAndDrop();
                
                // Zoom controls
                const zoomInBtn = document.querySelector('.zoom-btn:last-child');
                const zoomOutBtn = document.querySelector('.zoom-btn:first-child');
                
                zoomInBtn?.addEventListener('click', () => this.zoomIn());
                zoomOutBtn?.addEventListener('click', () => this.zoomOut());
                
                // View mode toggle
                const viewModeButtons = document.querySelectorAll('.view-mode-btn');
                viewModeButtons.forEach(btn => {
                    btn.addEventListener('click', (e) => {
                        const mode = e.target.textContent.toLowerCase();
                        this.setViewMode(mode);
                    });
                });
                
                // Paper size change
                const paperSizeSelect = document.querySelector('select[class*="property-select"]:first-child');
                paperSizeSelect?.addEventListener('change', (e) => {
                    this.setPaperSize(e.target.value);
                });
                
                // Orientation change
                const orientationSelect = document.querySelectorAll('select[class*="property-select"]')[1];
                orientationSelect?.addEventListener('change', (e) => {
                    this.setOrientation(e.target.value);
                });
                
                // Margin change
                const marginInput = document.querySelector('input[type="number"]');
                marginInput?.addEventListener('change', (e) => {
                    this.setMargin(parseInt(e.target.value));
                });
                
                // Grid settings
                const showGridCheckbox = document.querySelector('input[type="checkbox"]:first-of-type');
                const snapToGridCheckbox = document.querySelector('input[type="checkbox"]:nth-of-type(2)');
                const gridSizeInput = document.querySelector('input[type="number"]:last-of-type');
                
                showGridCheckbox?.addEventListener('change', (e) => {
                    this.toggleGrid(e.target.checked);
                });
                
                snapToGridCheckbox?.addEventListener('change', (e) => {
                    this.toggleSnapToGrid(e.target.checked);
                });
                
                gridSizeInput?.addEventListener('change', (e) => {
                    this.setGridSize(parseInt(e.target.value));
                });
                
                // Header buttons
                const headerButtons = document.querySelectorAll('.header-btn');
                headerButtons.forEach(btn => {
                    btn.addEventListener('click', (e) => {
                        const text = e.target.textContent.trim();
                        this.handleHeaderAction(text);
                    });
                });
                
                // Canvas zoom with mouse wheel
                const canvasContainer = document.querySelector('.canvas-container');
                canvasContainer?.addEventListener('wheel', (e) => {
                    if (e.ctrlKey || e.metaKey) {
                        e.preventDefault();
                        if (e.deltaY > 0) {
                            this.zoomOut();
                        } else {
                            this.zoomIn();
                        }
                    }
                });
                
                // Canvas interactions for drag-to-select and deselection
                const canvas = document.querySelector('.report-canvas');
                const canvasContainer = document.querySelector('.canvas-container');
                
                canvas?.addEventListener('mousedown', (e) => {
                    // Only handle if clicking on canvas itself, not on elements
                    if (e.target === canvas || e.target.classList.contains('drop-zone') || e.target.classList.contains('canvas-grid')) {
                        // Check if this is a drag-to-select operation
                        if (e.button === 0) { // Left mouse button
                            this.startDragToSelect(e);
                        }
                    }
                });
                
                canvas?.addEventListener('click', (e) => {
                    // Only deselect if clicking on canvas itself, not on elements
                    if (e.target === canvas || e.target.classList.contains('drop-zone') || e.target.classList.contains('canvas-grid')) {
                        // Only deselect if we didn't just finish a drag-to-select operation
                        if (!this.isSelectionBoxActive) {
                            this.deselectAllElements();
                        }
                    }
                });
                
                // Keyboard shortcuts
                document.addEventListener('keydown', (e) => {
                    this.handleKeyboardShortcuts(e);
                });
                
                // Property panel input handlers
                this.setupPropertyPanelHandlers();
                
                // Context menu setup
                this.setupContextMenu();
                
                // Selection handles setup
                this.setupSelectionHandles();
                
                // Click outside to hide context menu
                document.addEventListener('click', (e) => {
                    if (!e.target.closest('.context-menu') && !e.target.closest('.canvas-element')) {
                        this.hideContextMenu();
                    }
                });
                
                document.addEventListener('contextmenu', (e) => {
                    if (!e.target.closest('.canvas-element')) {
                        this.hideContextMenu();
                    }
                });
            }
            
            zoomIn() {
                if (this.currentZoom < this.maxZoom) {
                    this.currentZoom += this.zoomStep;
                    this.applyZoom();
                    this.updateZoomDisplay();
                    this.updateStatusBar();
                    this.showNotification(`Zoom: ${this.currentZoom}%`, 'info');
                }
            }
            
            zoomOut() {
                if (this.currentZoom > this.minZoom) {
                    this.currentZoom -= this.zoomStep;
                    this.applyZoom();
                    this.updateZoomDisplay();
                    this.updateStatusBar();
                    this.showNotification(`Zoom: ${this.currentZoom}%`, 'info');
                }
            }
            
            applyZoom() {
                const canvas = document.querySelector('.report-canvas');
                if (canvas) {
                    canvas.style.transform = `scale(${this.currentZoom / 100})`;
                    canvas.style.transformOrigin = 'top center';
                }
            }
            
            updateZoomDisplay() {
                const zoomDisplay = document.querySelector('.zoom-display');
                if (zoomDisplay) {
                    zoomDisplay.textContent = `${this.currentZoom}%`;
                }
            }
            
            setViewMode(mode) {
                this.currentView = mode;
                
                // Update button states
                document.querySelectorAll('.view-mode-btn').forEach(btn => {
                    btn.classList.remove('active');
                    if (btn.textContent.toLowerCase() === mode) {
                        btn.classList.add('active');
                    }
                });
                
                const canvas = document.querySelector('.report-canvas');
                const emptyState = document.querySelector('.canvas-empty-state');
                
                if (mode === 'preview') {
                    // Hide grid and empty state in preview mode
                    document.querySelector('.canvas-grid')?.classList.remove('show-grid');
                    if (emptyState && this.elementCount === 0) {
                        emptyState.style.display = 'none';
                    }
                    canvas?.classList.add('preview-mode');
                    this.showNotification('Switched to Preview mode', 'info');
                } else {
                    // Show grid and empty state in design mode
                    if (this.showGrid) {
                        document.querySelector('.canvas-grid')?.classList.add('show-grid');
                    }
                    if (emptyState && this.elementCount === 0) {
                        emptyState.style.display = 'block';
                    }
                    canvas?.classList.remove('preview-mode');
                    this.showNotification('Switched to Design mode', 'info');
                }
                
                this.updateStatusBar();
            }
            
            setPaperSize(size) {
                this.paperSize = size;
                const canvas = document.querySelector('.report-canvas');
                
                // Remove existing size classes
                canvas?.classList.remove('canvas-a4', 'canvas-letter', 'canvas-legal');
                
                // Add new size class
                switch(size) {
                    case 'letter':
                        canvas?.classList.add('canvas-letter');
                        break;
                    case 'legal':
                        canvas?.classList.add('canvas-legal');
                        break;
                    default:
                        canvas?.classList.add('canvas-a4');
                }
                
                this.updateStatusBar();
                this.showNotification(`Paper size changed to ${size.toUpperCase()}`, 'success');
            }
            
            setOrientation(orientation) {
                this.orientation = orientation;
                const canvas = document.querySelector('.report-canvas');
                
                if (canvas) {
                    if (orientation === 'landscape') {
                        const currentWidth = canvas.style.width || canvas.offsetWidth;
                        const currentHeight = canvas.style.height || canvas.offsetHeight;
                        canvas.style.width = currentHeight;
                        canvas.style.height = currentWidth;
                    } else {
                        // Reset to portrait - you might need to store original dimensions
                        this.setPaperSize(this.paperSize); // Reapply paper size to get correct dimensions
                    }
                }
                
                this.updateStatusBar();
                this.showNotification(`Orientation changed to ${orientation}`, 'success');
            }
            
            setMargin(margin) {
                this.margin = margin;
                // Apply margin to canvas content area (you'll implement this with elements later)
                this.showNotification(`Margin set to ${margin}mm`, 'success');
            }
            
            toggleGrid(show) {
                this.showGrid = show;
                const grid = document.querySelector('.canvas-grid');
                
                if (show && this.currentView === 'design') {
                    grid?.classList.add('show-grid');
                } else {
                    grid?.classList.remove('show-grid');
                }
                
                this.updateStatusBar();
                this.showNotification(`Grid ${show ? 'enabled' : 'disabled'}`, 'info');
            }
            
            toggleSnapToGrid(snap) {
                this.snapToGrid = snap;
                this.showNotification(`Snap to grid ${snap ? 'enabled' : 'disabled'}`, 'info');
            }
            
            setGridSize(size) {
                this.gridSize = size;
                const grid = document.querySelector('.canvas-grid');
                
                if (grid) {
                    grid.style.backgroundSize = `${size}px ${size}px`;
                }
                
                this.updateStatusBar();
                this.showNotification(`Grid size set to ${size}px`, 'info');
            }
            
            handleHeaderAction(action) {
                switch(action) {
                    case '↶ Undo':
                        this.performUndo();
                        break;
                    case '↷ Redo':
                        this.performRedo();
                        break;
                    case '💾 Save':
                        this.saveReport();
                        break;
                    case '👁️ Preview':
                        this.previewReport();
                        break;
                    case '🚀 Publish':
                        this.publishReport();
                        break;
                    case '❌ Close':
                        this.closeDesigner();
                        break;
                }
            }
            
            saveReport() {
                // Simulate save operation
                this.showNotification('Report saved successfully!', 'success');
                console.log('Saving report...', {
                    paperSize: this.paperSize,
                    orientation: this.orientation,
                    margin: this.margin,
                    zoom: this.currentZoom,
                    elements: this.elementCount
                });
            }
            
            previewReport() {
                this.setViewMode('preview');
            }
            
            publishReport() {
                if (this.elementCount === 0) {
                    this.showNotification('Add some components before publishing', 'warning');
                    return;
                }
                this.showNotification('Publishing report...', 'info');
                // Simulate publish operation
                setTimeout(() => {
                    this.showNotification('Report published successfully!', 'success');
                }, 2000);
            }
            
            closeDesigner() {
                if (confirm('Are you sure you want to close the designer? Any unsaved changes will be lost.')) {
                    window.close();
                }
            }
            
            // Perform undo operation
            performUndo() {
                const result = this.actionHistory.undo();
                
                if (result.success) {
                    // Enhanced visual feedback for undo
                    this.showNotification(result.message, 'info');
                    this.flashUndoRedoButton('undo');
                    this.updateUndoRedoButtons();
                    
                    // Update canvas state if needed
                    this.updateCanvasAfterAction();
                    
                    // Show brief history status
                    this.showHistoryStatus();
                } else {
                    this.showNotification(result.message, 'warning');
                    this.shakeUndoRedoButton('undo');
                }
            }
            
            // Perform redo operation
            performRedo() {
                const result = this.actionHistory.redo();
                
                if (result.success) {
                    // Enhanced visual feedback for redo
                    this.showNotification(result.message, 'info');
                    this.flashUndoRedoButton('redo');
                    this.updateUndoRedoButtons();
                    
                    // Update canvas state if needed
                    this.updateCanvasAfterAction();
                    
                    // Show brief history status
                    this.showHistoryStatus();
                } else {
                    this.showNotification(result.message, 'warning');
                    this.shakeUndoRedoButton('redo');
                }
            }
            
            // Flash effect for successful undo/redo button press
            flashUndoRedoButton(buttonType) {
                const buttonId = buttonType === 'undo' ? 'undo-btn' : 'redo-btn';
                const button = document.getElementById(buttonId);
                
                if (button) {
                    button.style.transform = 'scale(0.95)';
                    button.style.background = 'rgba(255,255,255,0.4)';
                    
                    setTimeout(() => {
                        button.style.transform = '';
                        button.style.background = '';
                    }, 150);
                }
            }
            
            // Shake effect for failed undo/redo button press
            shakeUndoRedoButton(buttonType) {
                const buttonId = buttonType === 'undo' ? 'undo-btn' : 'redo-btn';
                const button = document.getElementById(buttonId);
                
                if (button) {
                    button.style.animation = 'shake 0.5s ease-in-out';
                    
                    setTimeout(() => {
                        button.style.animation = '';
                    }, 500);
                }
            }
            
            // Show brief history status overlay
            showHistoryStatus() {
                const status = this.actionHistory.getStatus();
                const statusText = `History: ${status.undoCount} undo | ${status.redoCount} redo`;
                
                // Remove existing status
                const existingStatus = document.querySelector('.history-status');
                if (existingStatus) {
                    existingStatus.remove();
                }
                
                // Create status overlay
                const statusOverlay = document.createElement('div');
                statusOverlay.className = 'history-status';
                statusOverlay.style.cssText = `
                    position: fixed;
                    bottom: 50px;
                    left: 50%;
                    transform: translateX(-50%);
                    background: rgba(0, 0, 0, 0.8);
                    color: white;
                    padding: 8px 16px;
                    border-radius: 20px;
                    font-size: 12px;
                    font-weight: 500;
                    z-index: 1002;
                    opacity: 0;
                    transition: opacity 0.3s ease;
                    pointer-events: none;
                `;
                
                statusOverlay.textContent = statusText;
                document.body.appendChild(statusOverlay);
                
                // Animate in
                requestAnimationFrame(() => {
                    statusOverlay.style.opacity = '1';
                });
                
                // Auto-remove after 2 seconds
                setTimeout(() => {
                    if (statusOverlay.parentNode) {
                        statusOverlay.style.opacity = '0';
                        setTimeout(() => statusOverlay.remove(), 300);
                    }
                }, 2000);
            }
            
            // Update canvas state after actions
            updateCanvasAfterAction() {
                // Refresh empty state visibility
                const emptyState = document.querySelector('.canvas-empty-state');
                if (emptyState) {
                    emptyState.style.display = this.elementCount === 0 ? 'block' : 'none';
                }
                
                // Update selection if the selected element was removed
                if (this.selectedElement && !this.selectedElement.parentNode) {
                    this.deselectAllElements();
                }
                
                // Update selection handles if element still exists
                if (this.selectedElement && this.selectedElement.parentNode) {
                    this.updateSelectionHandles();
                }
                
                // Update status bar
                this.updateStatusBar();
            }
            
            // Update undo/redo button states
            updateUndoRedoButtons() {
                const undoBtn = document.getElementById('undo-btn');
                const redoBtn = document.getElementById('redo-btn');
                
                if (undoBtn) {
                    undoBtn.disabled = !this.actionHistory.canUndo();
                    undoBtn.title = this.actionHistory.canUndo() 
                        ? `Undo (Ctrl+Z) - ${this.actionHistory.getStatus().lastAction}` 
                        : 'Nothing to undo';
                }
                
                if (redoBtn) {
                    redoBtn.disabled = !this.actionHistory.canRedo();
                    redoBtn.title = this.actionHistory.canRedo() 
                        ? 'Redo (Ctrl+Y)' 
                        : 'Nothing to redo';
                }
            }
            
            updateStatusBar() {
                const statusItems = document.querySelectorAll('.status-item');
                if (statusItems.length >= 4) {
                    statusItems[0].textContent = `Elements: ${this.elementCount}`;
                    statusItems[1].textContent = `Canvas: ${this.paperSize.toUpperCase()} ${this.orientation}`;
                    statusItems[2].textContent = `Grid: ${this.showGrid ? this.gridSize + 'px' : 'Off'}`;
                    statusItems[3].textContent = `Zoom: ${this.currentZoom}% | ${this.currentView.toUpperCase()} Mode`;
                }
            }
            
            setupDragAndDrop() {
                const componentItems = document.querySelectorAll('.component-item');
                const dropZone = document.querySelector('.drop-zone');
                const canvas = document.querySelector('.report-canvas');
                
                // Make component items draggable
                componentItems.forEach(item => {
                    item.draggable = true;
                    
                    item.addEventListener('dragstart', (e) => {
                        const componentType = item.dataset.component;
                        const componentName = item.querySelector('.component-name').textContent;
                        const componentIcon = item.querySelector('.component-icon').textContent;
                        
                        e.dataTransfer.setData('text/plain', JSON.stringify({
                            type: componentType,
                            name: componentName,
                            icon: componentIcon
                        }));
                        
                        e.dataTransfer.effectAllowed = 'copy';
                        
                        // Add visual feedback
                        item.style.opacity = '0.5';
                        this.showNotification(`Dragging ${componentName}`, 'info');
                    });
                    
                    item.addEventListener('dragend', (e) => {
                        // Reset visual feedback
                        item.style.opacity = '1';
                    });
                });
                
                // Setup drop zone
                canvas.addEventListener('dragover', (e) => {
                    e.preventDefault();
                    e.dataTransfer.dropEffect = 'copy';
                    dropZone.classList.add('drag-over');
                });
                
                canvas.addEventListener('dragleave', (e) => {
                    if (!canvas.contains(e.relatedTarget)) {
                        dropZone.classList.remove('drag-over');
                    }
                });
                
                canvas.addEventListener('drop', (e) => {
                    e.preventDefault();
                    dropZone.classList.remove('drag-over');
                    
                    try {
                        const componentData = JSON.parse(e.dataTransfer.getData('text/plain'));
                        const rect = canvas.getBoundingClientRect();
                        const x = e.clientX - rect.left;
                        const y = e.clientY - rect.top;
                        
                        this.addComponentToCanvas(componentData, x, y);
                    } catch (error) {
                        console.error('Error processing drop:', error);
                        this.showNotification('Error adding component', 'warning');
                    }
                });
            }
            
            addComponentToCanvas(componentData, x, y) {
                // Snap to grid if enabled
                if (this.snapToGrid) {
                    x = Math.round(x / this.gridSize) * this.gridSize;
                    y = Math.round(y / this.gridSize) * this.gridSize;
                }
                
                // Create component element
                const element = this.createCanvasElement(componentData, x, y);
                
                const canvas = document.querySelector('.report-canvas');
                
                // Create and execute add element action
                const addAction = new AddElementAction(element, canvas, this);
                const success = this.actionHistory.executeAction(addAction);
                
                if (success) {
                    // Update undo/redo button states
                    this.updateUndoRedoButtons();
                    this.showNotification(`Added ${componentData.name}`, 'success');
                } else {
                    this.showNotification(`Failed to add ${componentData.name}`, 'warning');
                }
            }
            
            createCanvasElement(componentData, x, y) {
                const element = document.createElement('div');
                element.className = 'canvas-element';
                element.dataset.componentType = componentData.type;
                element.style.cssText = `
                    position: absolute;
                    left: ${x}px;
                    top: ${y}px;
                    cursor: move;
                    border: 2px solid transparent;
                    padding: 12px;
                    background: white;
                    border-radius: 4px;
                    min-width: 120px;
                    min-height: 40px;
                    transition: all 0.15s ease;
                    box-shadow: 0 2px 4px rgba(0,0,0,0.1);
                `;
                
                // Create content based on component type
                const content = this.getComponentContent(componentData);
                element.innerHTML = content;
                
                // Add element interactions
                this.setupElementInteractions(element);
                
                // Add image upload support for image elements
                if (componentData.type === 'image') {
                    this.setupImageUpload(element);
                }
                
                return element;
            }
            
            getComponentContent(componentData) {
                const { type, name, icon } = componentData;
                
                switch(type) {
                    case 'header':
                        return `
                            <div style="display: flex; align-items: center; gap: 8px;">
                                <span style="font-size: 18px;">${icon}</span>
                                <h2 style="margin: 0; font-size: 18px; color: #333;">Report Header</h2>
                            </div>
                        `;
                    
                    case 'text':
                        return `
                            <div style="display: flex; align-items: center; gap: 8px;">
                                <span style="font-size: 16px;">${icon}</span>
                                <p style="margin: 0; color: #555; font-size: 14px;">Sample text content. Double-click to edit.</p>
                            </div>
                        `;
                    
                    case 'table':
                        return `
                            <div>
                                <div style="display: flex; align-items: center; gap: 8px; margin-bottom: 8px;">
                                    <span style="font-size: 16px;">${icon}</span>
                                    <strong style="font-size: 14px;">Data Table</strong>
                                </div>
                                <div style="border: 1px solid #ddd; border-radius: 4px; overflow: hidden;">
                                    <div style="background: #f8f9fa; padding: 6px 8px; font-size: 12px; font-weight: bold;">Column A | Column B | Column C</div>
                                    <div style="padding: 6px 8px; font-size: 12px; border-top: 1px solid #eee;">Row 1 Data | Row 1 Data | Row 1 Data</div>
                                    <div style="padding: 6px 8px; font-size: 12px; border-top: 1px solid #eee;">Row 2 Data | Row 2 Data | Row 2 Data</div>
                                </div>
                            </div>
                        `;
                    
                    case 'image':
                        return `
                            <div style="text-align: center;" class="image-drop-zone">
                                <div style="border: 2px dashed #ddd; padding: 20px; border-radius: 4px;" class="image-placeholder">
                                    <div style="font-size: 24px; margin-bottom: 4px;">${icon}</div>
                                    <div style="font-size: 12px; color: #666;">Drop image or click to upload</div>
                                </div>
                                <div class="image-upload-feedback">📁 Drop image here</div>
                            </div>
                        `;
                    
                    case 'bar-chart':
                        return `
                            <div>
                                <div style="display: flex; align-items: center; gap: 8px; margin-bottom: 8px;">
                                    <span style="font-size: 16px;">${icon}</span>
                                    <strong style="font-size: 14px;">Bar Chart</strong>
                                </div>
                                <div style="display: flex; align-items: end; gap: 4px; height: 60px; padding: 8px; background: #f8f9fa; border-radius: 4px;">
                                    <div style="background: #007bff; width: 12px; height: 40px;"></div>
                                    <div style="background: #28a745; width: 12px; height: 50px;"></div>
                                    <div style="background: #ffc107; width: 12px; height: 30px;"></div>
                                    <div style="background: #dc3545; width: 12px; height: 45px;"></div>
                                </div>
                            </div>
                        `;
                    
                    case 'line-chart':
                        return `
                            <div>
                                <div style="display: flex; align-items: center; gap: 8px; margin-bottom: 8px;">
                                    <span style="font-size: 16px;">${icon}</span>
                                    <strong style="font-size: 14px;">Line Chart</strong>
                                </div>
                                <div style="height: 60px; padding: 8px; background: #f8f9fa; border-radius: 4px; position: relative;">
                                    <svg width="100%" height="100%" style="position: absolute; top: 0; left: 0;">
                                        <polyline fill="none" stroke="#007bff" stroke-width="2" 
                                                  points="10,40 30,20 50,35 70,15 90,25"/>
                                    </svg>
                                </div>
                            </div>
                        `;
                    
                    case 'pie-chart':
                        return `
                            <div>
                                <div style="display: flex; align-items: center; gap: 8px; margin-bottom: 8px;">
                                    <span style="font-size: 16px;">${icon}</span>
                                    <strong style="font-size: 14px;">Pie Chart</strong>
                                </div>
                                <div style="display: flex; justify-content: center; padding: 8px; background: #f8f9fa; border-radius: 4px;">
                                    <div style="width: 50px; height: 50px; border-radius: 50%; background: conic-gradient(#007bff 0deg 120deg, #28a745 120deg 240deg, #ffc107 240deg 360deg);"></div>
                                </div>
                            </div>
                        `;
                    
                    case 'number':
                        return `
                            <div style="text-align: center;">
                                <div style="display: flex; align-items: center; gap: 8px; justify-content: center; margin-bottom: 4px;">
                                    <span style="font-size: 16px;">${icon}</span>
                                    <span style="font-size: 24px; font-weight: bold; color: #007bff;">42</span>
                                </div>
                                <div style="font-size: 12px; color: #666;">Total Count</div>
                            </div>
                        `;
                    
                    case 'progress':
                        return `
                            <div>
                                <div style="display: flex; align-items: center; gap: 8px; margin-bottom: 8px;">
                                    <span style="font-size: 16px;">${icon}</span>
                                    <strong style="font-size: 14px;">Progress</strong>
                                </div>
                                <div style="background: #e9ecef; height: 20px; border-radius: 10px; overflow: hidden;">
                                    <div style="background: #28a745; height: 100%; width: 65%; border-radius: 10px; display: flex; align-items: center; justify-content: center; color: white; font-size: 11px; font-weight: bold;">65%</div>
                                </div>
                            </div>
                        `;
                    
                    case 'metric':
                        return `
                            <div style="padding: 8px; border: 1px solid #ddd; border-radius: 4px; text-align: center;">
                                <div style="display: flex; align-items: center; gap: 8px; justify-content: center; margin-bottom: 4px;">
                                    <span style="font-size: 16px;">${icon}</span>
                                    <span style="color: #28a745; font-size: 12px;">▲ 12.5%</span>
                                </div>
                                <div style="font-size: 18px; font-weight: bold; color: #333;">$125,430</div>
                                <div style="font-size: 11px; color: #666;">Revenue</div>
                            </div>
                        `;
                    
                    case 'divider':
                        return `
                            <div style="display: flex; align-items: center; width: 200px;">
                                <div style="flex: 1; height: 1px; background: #dee2e6;"></div>
                                <span style="margin: 0 8px; font-size: 12px; color: #666;">${icon}</span>
                                <div style="flex: 1; height: 1px; background: #dee2e6;"></div>
                            </div>
                        `;
                    
                    default:
                        return `
                            <div style="display: flex; align-items: center; gap: 8px;">
                                <span style="font-size: 16px;">${icon}</span>
                                <span style="font-size: 14px;">${name}</span>
                            </div>
                        `;
                }
            }
            
            setupElementInteractions(element) {
                // Hover effects
                element.addEventListener('mouseenter', () => {
                    if (!element.classList.contains('selected')) {
                        element.style.borderColor = '#007bff';
                        element.style.boxShadow = '0 4px 12px rgba(0,123,255,0.2)';
                    }
                });
                
                element.addEventListener('mouseleave', () => {
                    if (!element.classList.contains('selected')) {
                        element.style.borderColor = 'transparent';
                        element.style.boxShadow = '0 2px 4px rgba(0,0,0,0.1)';
                    }
                });
                
                // Click to select with multi-select support
                element.addEventListener('click', (e) => {
                    e.stopPropagation();
                    
                    if (e.ctrlKey || e.metaKey) {
                        // Multi-select mode
                        this.toggleElementInMultiSelection(element);
                    } else {
                        // Single select mode
                        this.selectElement(element);
                    }
                });
                
                // Double-click to edit
                element.addEventListener('dblclick', (e) => {
                    e.stopPropagation();
                    this.startInlineEditing(element);
                });
                
                // Make draggable within canvas
                this.makeElementDraggable(element);
            }
            
            makeElementDraggable(element) {
                let isDragging = false;
                let startX, startY, startLeft, startTop;
                let hasMovedSignificantly = false;
                
                element.addEventListener('mousedown', (e) => {
                    if (e.button !== 0) return; // Only left click
                    
                    isDragging = true;
                    hasMovedSignificantly = false;
                    startX = e.clientX;
                    startY = e.clientY;
                    startLeft = parseInt(element.style.left) || 0;
                    startTop = parseInt(element.style.top) || 0;
                    
                    element.style.cursor = 'grabbing';
                    element.style.zIndex = '1000';
                    
                    e.preventDefault();
                });
                
                document.addEventListener('mousemove', (e) => {
                    if (!isDragging) return;
                    
                    const deltaX = e.clientX - startX;
                    const deltaY = e.clientY - startY;
                    
                    // Check if moved significantly (more than 5 pixels)
                    if (!hasMovedSignificantly && (Math.abs(deltaX) > 5 || Math.abs(deltaY) > 5)) {
                        hasMovedSignificantly = true;
                    }
                    
                    let newLeft = startLeft + deltaX;
                    let newTop = startTop + deltaY;
                    
                    // Snap to grid if enabled
                    if (this.snapToGrid) {
                        newLeft = Math.round(newLeft / this.gridSize) * this.gridSize;
                        newTop = Math.round(newTop / this.gridSize) * this.gridSize;
                    }
                    
                    // Keep within canvas bounds
                    const canvas = document.querySelector('.report-canvas');
                    const canvasRect = canvas.getBoundingClientRect();
                    const elementRect = element.getBoundingClientRect();
                    
                    newLeft = Math.max(0, Math.min(newLeft, canvasRect.width - elementRect.width));
                    newTop = Math.max(0, Math.min(newTop, canvasRect.height - elementRect.height));
                    
                    element.style.left = newLeft + 'px';
                    element.style.top = newTop + 'px';
                });
                
                document.addEventListener('mouseup', () => {
                    if (isDragging) {
                        // Only create move action if the element actually moved significantly
                        if (hasMovedSignificantly) {
                            const finalLeft = parseInt(element.style.left) || 0;
                            const finalTop = parseInt(element.style.top) || 0;
                            
                            // Only create action if position actually changed
                            if (finalLeft !== startLeft || finalTop !== startTop) {
                                const moveAction = new MoveElementAction(
                                    element,
                                    { x: startLeft, y: startTop },
                                    { x: finalLeft, y: finalTop }
                                );
                                
                                // Execute the action through history system (but don't re-execute since element is already moved)
                                this.actionHistory.isRecording = false;
                                moveAction.execute = () => {}; // Prevent re-execution since element is already in final position
                                this.actionHistory.isRecording = true;
                                
                                this.actionHistory.executeAction(moveAction);
                                this.updateUndoRedoButtons();
                                
                                // Update selected element data if this element is selected
                                if (this.selectedElement === element) {
                                    this.selectedElementData.x = finalLeft;
                                    this.selectedElementData.y = finalTop;
                                    this.updateSelectionHandles();
                                    
                                    // Update position inputs if visible
                                    const elementX = document.getElementById('element-x');
                                    const elementY = document.getElementById('element-y');
                                    if (elementX) elementX.value = finalLeft;
                                    if (elementY) elementY.value = finalTop;
                                }
                            }
                        }
                        
                        isDragging = false;
                        hasMovedSignificantly = false;
                        element.style.cursor = 'move';
                        element.style.zIndex = 'auto';
                    }
                });
            }
            
            selectElement(element) {
                // Deselect all elements first
                this.deselectAllElements();
                
                // Select clicked element
                element.classList.add('selected');
                element.style.borderColor = '#007bff';
                element.style.boxShadow = '0 4px 12px rgba(0,123,255,0.2)';
                
                // Update internal state
                this.selectedElement = element;
                this.selectedElementData = {
                    type: element.dataset.componentType,
                    x: parseInt(element.style.left) || 0,
                    y: parseInt(element.style.top) || 0,
                    width: element.offsetWidth,
                    height: element.offsetHeight
                };
                
                // Update properties panel
                this.updatePropertiesPanel();
                
                // Show selection handles
                this.updateSelectionHandles();
                
                this.showNotification(`Selected ${element.dataset.componentType}`, 'info');
            }
            
            deselectAllElements() {
                // Clear visual selection from all elements
                document.querySelectorAll('.canvas-element').forEach(el => {
                    el.classList.remove('selected');
                    el.style.borderColor = 'transparent';
                    el.style.boxShadow = '0 2px 4px rgba(0,0,0,0.1)';
                });
                
                // Clear internal state
                this.selectedElement = null;
                this.selectedElementData = null;
                this.selectedElements.clear();
                this.isMultiSelectMode = false;
                
                // Hide selection handles
                this.hideSelectionHandles();
                
                // Update properties panel to show canvas settings
                this.updatePropertiesPanel();
            }
            
            // Multi-select functionality
            toggleElementInMultiSelection(element) {
                if (this.selectedElements.has(element)) {
                    // Remove from multi-selection
                    this.selectedElements.delete(element);
                    element.classList.remove('selected');
                    element.style.borderColor = 'transparent';
                    element.style.boxShadow = '0 2px 4px rgba(0,0,0,0.1)';
                } else {
                    // Add to multi-selection
                    this.selectedElements.add(element);
                    element.classList.add('selected');
                    element.style.borderColor = '#007bff';
                    element.style.boxShadow = '0 4px 12px rgba(0,123,255,0.2)';
                }
                
                // Update multi-select mode
                this.isMultiSelectMode = this.selectedElements.size > 0;
                
                // Update single element selection if only one element is selected
                if (this.selectedElements.size === 1) {
                    const singleElement = Array.from(this.selectedElements)[0];
                    this.selectedElement = singleElement;
                    this.selectedElementData = {
                        type: singleElement.dataset.componentType,
                        x: parseInt(singleElement.style.left) || 0,
                        y: parseInt(singleElement.style.top) || 0,
                        width: singleElement.offsetWidth,
                        height: singleElement.offsetHeight
                    };
                    this.updateSelectionHandles();
                } else {
                    // Clear single selection for multi-selection
                    this.selectedElement = null;
                    this.selectedElementData = null;
                    this.hideSelectionHandles();
                }
                
                this.updatePropertiesPanel();
                
                // Show notification
                if (this.selectedElements.size === 0) {
                    this.showNotification('No elements selected', 'info');
                } else if (this.selectedElements.size === 1) {
                    this.showNotification(`Selected ${Array.from(this.selectedElements)[0].dataset.componentType}`, 'info');
                } else {
                    this.showNotification(`${this.selectedElements.size} elements selected`, 'info');
                }
            }
            
            updatePropertiesPanel() {
                const subtitle = document.getElementById('properties-subtitle');
                const canvasSettings = document.getElementById('canvas-settings');
                const gridSettings = document.getElementById('grid-settings');
                const elementProperties = document.getElementById('element-properties');
                const positionProperties = document.getElementById('position-properties');
                const styleProperties = document.getElementById('style-properties');
                
                if (this.selectedElement && this.selectedElementData) {
                    // Show element properties
                    subtitle.textContent = `${this.selectedElementData.type.charAt(0).toUpperCase() + this.selectedElementData.type.slice(1)} Properties`;
                    
                    // Hide canvas/grid settings
                    canvasSettings.style.display = 'none';
                    gridSettings.style.display = 'none';
                    
                    // Show element property groups
                    elementProperties.style.display = 'block';
                    positionProperties.style.display = 'block';
                    styleProperties.style.display = 'block';
                    
                    // Update element properties title
                    document.getElementById('element-properties-title').textContent = 
                        `${this.selectedElementData.type.charAt(0).toUpperCase() + this.selectedElementData.type.slice(1)} Properties`;
                    
                    // Populate dynamic element-specific properties
                    this.populateElementProperties();
                    
                    // Update position values
                    document.getElementById('element-x').value = this.selectedElementData.x;
                    document.getElementById('element-y').value = this.selectedElementData.y;
                    document.getElementById('element-width').value = this.selectedElementData.width;
                    document.getElementById('element-height').value = this.selectedElementData.height;
                    
                    // Update style values from computed styles
                    const computedStyle = getComputedStyle(this.selectedElement);
                    document.getElementById('element-bg-color').value = this.rgbToHex(computedStyle.backgroundColor);
                    document.getElementById('element-bg-color-text').value = this.rgbToHex(computedStyle.backgroundColor);
                    document.getElementById('element-border-width').value = parseInt(computedStyle.borderWidth) || 2;
                    document.getElementById('element-border-radius').value = parseInt(computedStyle.borderRadius) || 4;
                    document.getElementById('element-padding').value = parseInt(computedStyle.padding) || 12;
                    
                } else {
                    // Show canvas properties
                    subtitle.textContent = 'Select an element to edit its properties';
                    
                    // Show canvas/grid settings
                    canvasSettings.style.display = 'block';
                    gridSettings.style.display = 'block';
                    
                    // Hide element property groups
                    elementProperties.style.display = 'none';
                    positionProperties.style.display = 'none';
                    styleProperties.style.display = 'none';
                }
            }
            
            // Initialize property templates for different element types
            initializePropertyTemplates() {
                return {
                    'header': {
                        content: {
                            type: 'text',
                            label: 'Header Text',
                            defaultValue: 'Report Header',
                            placeholder: 'Enter header text'
                        },
                        fontSize: {
                            type: 'number',
                            label: 'Font Size (px)',
                            defaultValue: 18,
                            min: 12,
                            max: 48
                        },
                        fontWeight: {
                            type: 'select',
                            label: 'Font Weight',
                            defaultValue: 'bold',
                            options: [
                                { value: 'normal', label: 'Normal' },
                                { value: 'bold', label: 'Bold' },
                                { value: '600', label: 'Semi Bold' }
                            ]
                        },
                        textColor: {
                            type: 'color',
                            label: 'Text Color',
                            defaultValue: '#333333'
                        },
                        alignment: {
                            type: 'select',
                            label: 'Text Alignment',
                            defaultValue: 'left',
                            options: [
                                { value: 'left', label: 'Left' },
                                { value: 'center', label: 'Center' },
                                { value: 'right', label: 'Right' }
                            ]
                        }
                    },
                    'text': {
                        content: {
                            type: 'textarea',
                            label: 'Text Content',
                            defaultValue: 'Sample text content. Double-click to edit.',
                            placeholder: 'Enter your text content'
                        },
                        fontSize: {
                            type: 'number',
                            label: 'Font Size (px)',
                            defaultValue: 14,
                            min: 8,
                            max: 36
                        },
                        fontWeight: {
                            type: 'select',
                            label: 'Font Weight',
                            defaultValue: 'normal',
                            options: [
                                { value: 'normal', label: 'Normal' },
                                { value: 'bold', label: 'Bold' },
                                { value: '600', label: 'Semi Bold' }
                            ]
                        },
                        textColor: {
                            type: 'color',
                            label: 'Text Color',
                            defaultValue: '#555555'
                        },
                        alignment: {
                            type: 'select',
                            label: 'Text Alignment',
                            defaultValue: 'left',
                            options: [
                                { value: 'left', label: 'Left' },
                                { value: 'center', label: 'Center' },
                                { value: 'right', label: 'Right' },
                                { value: 'justify', label: 'Justify' }
                            ]
                        }
                    },
                    'table': {
                        title: {
                            type: 'text',
                            label: 'Table Title',
                            defaultValue: 'Data Table',
                            placeholder: 'Enter table title'
                        },
                        columns: {
                            type: 'number',
                            label: 'Number of Columns',
                            defaultValue: 3,
                            min: 1,
                            max: 10
                        },
                        rows: {
                            type: 'number',
                            label: 'Number of Rows',
                            defaultValue: 3,
                            min: 1,
                            max: 20
                        },
                        showHeaders: {
                            type: 'checkbox',
                            label: 'Show Header Row',
                            defaultValue: true
                        },
                        borderStyle: {
                            type: 'select',
                            label: 'Border Style',
                            defaultValue: 'solid',
                            options: [
                                { value: 'none', label: 'None' },
                                { value: 'solid', label: 'Solid' },
                                { value: 'dashed', label: 'Dashed' },
                                { value: 'dotted', label: 'Dotted' }
                            ]
                        },
                        headerBgColor: {
                            type: 'color',
                            label: 'Header Background',
                            defaultValue: '#f8f9fa'
                        }
                    },
                    'bar-chart': {
                        title: {
                            type: 'text',
                            label: 'Chart Title',
                            defaultValue: 'Bar Chart',
                            placeholder: 'Enter chart title'
                        },
                        dataSource: {
                            type: 'select',
                            label: 'Data Source',
                            defaultValue: 'sample',
                            options: [
                                { value: 'sample', label: 'Sample Data' },
                                { value: 'projects', label: 'Project Data' },
                                { value: 'revenue', label: 'Revenue Data' }
                            ]
                        },
                        colorScheme: {
                            type: 'select',
                            label: 'Color Scheme',
                            defaultValue: 'default',
                            options: [
                                { value: 'default', label: 'Default' },
                                { value: 'blue', label: 'Blue Tones' },
                                { value: 'green', label: 'Green Tones' },
                                { value: 'warm', label: 'Warm Colors' }
                            ]
                        },
                        showLegend: {
                            type: 'checkbox',
                            label: 'Show Legend',
                            defaultValue: true
                        },
                        xAxisLabel: {
                            type: 'text',
                            label: 'X-Axis Label',
                            defaultValue: '',
                            placeholder: 'Enter X-axis label'
                        },
                        yAxisLabel: {
                            type: 'text',
                            label: 'Y-Axis Label',
                            defaultValue: '',
                            placeholder: 'Enter Y-axis label'
                        }
                    },
                    'line-chart': {
                        title: {
                            type: 'text',
                            label: 'Chart Title',
                            defaultValue: 'Line Chart',
                            placeholder: 'Enter chart title'
                        },
                        dataSource: {
                            type: 'select',
                            label: 'Data Source',
                            defaultValue: 'sample',
                            options: [
                                { value: 'sample', label: 'Sample Data' },
                                { value: 'trends', label: 'Trend Data' },
                                { value: 'performance', label: 'Performance Data' }
                            ]
                        },
                        lineStyle: {
                            type: 'select',
                            label: 'Line Style',
                            defaultValue: 'solid',
                            options: [
                                { value: 'solid', label: 'Solid' },
                                { value: 'dashed', label: 'Dashed' },
                                { value: 'dotted', label: 'Dotted' }
                            ]
                        },
                        lineColor: {
                            type: 'color',
                            label: 'Line Color',
                            defaultValue: '#007bff'
                        },
                        showPoints: {
                            type: 'checkbox',
                            label: 'Show Data Points',
                            defaultValue: true
                        },
                        showLegend: {
                            type: 'checkbox',
                            label: 'Show Legend',
                            defaultValue: true
                        }
                    },
                    'pie-chart': {
                        title: {
                            type: 'text',
                            label: 'Chart Title',
                            defaultValue: 'Pie Chart',
                            placeholder: 'Enter chart title'
                        },
                        dataSource: {
                            type: 'select',
                            label: 'Data Source',
                            defaultValue: 'sample',
                            options: [
                                { value: 'sample', label: 'Sample Data' },
                                { value: 'budget', label: 'Budget Distribution' },
                                { value: 'progress', label: 'Progress Distribution' }
                            ]
                        },
                        showLabels: {
                            type: 'checkbox',
                            label: 'Show Labels',
                            defaultValue: true
                        },
                        showPercentages: {
                            type: 'checkbox',
                            label: 'Show Percentages',
                            defaultValue: true
                        },
                        showLegend: {
                            type: 'checkbox',
                            label: 'Show Legend',
                            defaultValue: true
                        }
                    },
                    'number': {
                        value: {
                            type: 'number',
                            label: 'Display Value',
                            defaultValue: 42,
                            step: 0.01
                        },
                        label: {
                            type: 'text',
                            label: 'Label Text',
                            defaultValue: 'Total Count',
                            placeholder: 'Enter label'
                        },
                        format: {
                            type: 'select',
                            label: 'Number Format',
                            defaultValue: 'number',
                            options: [
                                { value: 'number', label: 'Number' },
                                { value: 'currency', label: 'Currency' },
                                { value: 'percentage', label: 'Percentage' }
                            ]
                        },
                        fontSize: {
                            type: 'number',
                            label: 'Value Font Size (px)',
                            defaultValue: 24,
                            min: 16,
                            max: 48
                        },
                        valueColor: {
                            type: 'color',
                            label: 'Value Color',
                            defaultValue: '#007bff'
                        },
                        labelColor: {
                            type: 'color',
                            label: 'Label Color',
                            defaultValue: '#666666'
                        }
                    },
                    'progress': {
                        title: {
                            type: 'text',
                            label: 'Progress Title',
                            defaultValue: 'Progress',
                            placeholder: 'Enter title'
                        },
                        value: {
                            type: 'number',
                            label: 'Progress Value (%)',
                            defaultValue: 65,
                            min: 0,
                            max: 100
                        },
                        showPercentage: {
                            type: 'checkbox',
                            label: 'Show Percentage',
                            defaultValue: true
                        },
                        barColor: {
                            type: 'color',
                            label: 'Progress Bar Color',
                            defaultValue: '#28a745'
                        },
                        backgroundColor: {
                            type: 'color',
                            label: 'Background Color',
                            defaultValue: '#e9ecef'
                        },
                        height: {
                            type: 'number',
                            label: 'Bar Height (px)',
                            defaultValue: 20,
                            min: 10,
                            max: 40
                        }
                    },
                    'metric': {
                        title: {
                            type: 'text',
                            label: 'Metric Title',
                            defaultValue: 'Revenue',
                            placeholder: 'Enter metric title'
                        },
                        value: {
                            type: 'text',
                            label: 'Metric Value',
                            defaultValue: '$125,430',
                            placeholder: 'Enter value'
                        },
                        change: {
                            type: 'text',
                            label: 'Change Indicator',
                            defaultValue: '▲ 12.5%',
                            placeholder: 'e.g. ▲ 12.5%'
                        },
                        changeColor: {
                            type: 'color',
                            label: 'Change Color',
                            defaultValue: '#28a745'
                        },
                        showBorder: {
                            type: 'checkbox',
                            label: 'Show Border',
                            defaultValue: true
                        }
                    },
                    'image': {
                        src: {
                            type: 'text',
                            label: 'Image URL',
                            defaultValue: '',
                            placeholder: 'Enter image URL or upload'
                        },
                        alt: {
                            type: 'text',
                            label: 'Alt Text',
                            defaultValue: 'Image',
                            placeholder: 'Enter alt text'
                        },
                        fit: {
                            type: 'select',
                            label: 'Image Fit',
                            defaultValue: 'cover',
                            options: [
                                { value: 'cover', label: 'Cover' },
                                { value: 'contain', label: 'Contain' },
                                { value: 'fill', label: 'Fill' },
                                { value: 'none', label: 'None' }
                            ]
                        },
                        showPlaceholder: {
                            type: 'checkbox',
                            label: 'Show Placeholder',
                            defaultValue: true
                        }
                    },
                    'divider': {
                        thickness: {
                            type: 'number',
                            label: 'Line Thickness (px)',
                            defaultValue: 1,
                            min: 1,
                            max: 10
                        },
                        color: {
                            type: 'color',
                            label: 'Line Color',
                            defaultValue: '#dee2e6'
                        },
                        style: {
                            type: 'select',
                            label: 'Line Style',
                            defaultValue: 'solid',
                            options: [
                                { value: 'solid', label: 'Solid' },
                                { value: 'dashed', label: 'Dashed' },
                                { value: 'dotted', label: 'Dotted' }
                            ]
                        },
                        width: {
                            type: 'number',
                            label: 'Width (px)',
                            defaultValue: 200,
                            min: 50,
                            max: 500
                        }
                    }
                };
            }
            
            // Dynamic property controls renderer
            renderElementProperties(elementType) {
                const template = this.elementPropertyTemplates[elementType];
                if (!template) return '';
                
                let html = '';
                
                for (const [propertyKey, propertyConfig] of Object.entries(template)) {
                    html += this.renderPropertyControl(propertyKey, propertyConfig, elementType);
                }
                
                return html;
            }
            
            renderPropertyControl(propertyKey, config, elementType) {
                const { type, label, defaultValue, placeholder, options, min, max, step } = config;
                const controlId = `${elementType}-${propertyKey}`;
                
                let controlHtml = '';
                
                switch (type) {
                    case 'text':
                        controlHtml = `
                            <div class="property-item">
                                <label class="property-label" for="${controlId}">${label}</label>
                                <input type="text" 
                                       class="property-input element-property-control" 
                                       id="${controlId}" 
                                       data-property="${propertyKey}" 
                                       data-element-type="${elementType}"
                                       value="${defaultValue || ''}" 
                                       placeholder="${placeholder || ''}">
                            </div>
                        `;
                        break;
                        
                    case 'textarea':
                        controlHtml = `
                            <div class="property-item">
                                <label class="property-label" for="${controlId}">${label}</label>
                                <textarea class="property-input property-textarea element-property-control" 
                                          id="${controlId}" 
                                          data-property="${propertyKey}" 
                                          data-element-type="${elementType}"
                                          placeholder="${placeholder || ''}" 
                                          rows="3">${defaultValue || ''}</textarea>
                            </div>
                        `;
                        break;
                        
                    case 'number':
                        controlHtml = `
                            <div class="property-item">
                                <label class="property-label" for="${controlId}">${label}</label>
                                <input type="number" 
                                       class="property-input element-property-control" 
                                       id="${controlId}" 
                                       data-property="${propertyKey}" 
                                       data-element-type="${elementType}"
                                       value="${defaultValue || 0}" 
                                       ${min !== undefined ? `min="${min}"` : ''}
                                       ${max !== undefined ? `max="${max}"` : ''}
                                       ${step !== undefined ? `step="${step}"` : ''}>
                            </div>
                        `;
                        break;
                        
                    case 'color':
                        controlHtml = `
                            <div class="property-item">
                                <label class="property-label" for="${controlId}">${label}</label>
                                <div class="color-input-wrapper">
                                    <input type="color" 
                                           class="property-input color-input element-property-control" 
                                           id="${controlId}" 
                                           data-property="${propertyKey}" 
                                           data-element-type="${elementType}"
                                           value="${defaultValue || '#000000'}">
                                    <input type="text" 
                                           class="property-input color-text element-property-control" 
                                           id="${controlId}-text" 
                                           data-property="${propertyKey}" 
                                           data-element-type="${elementType}"
                                           value="${defaultValue || '#000000'}">
                                </div>
                            </div>
                        `;
                        break;
                        
                    case 'select':
                        let optionsHtml = '';
                        if (options && Array.isArray(options)) {
                            optionsHtml = options.map(option => 
                                `<option value="${option.value}" 
                                         ${option.value === defaultValue ? 'selected' : ''}>
                                    ${option.label}
                                 </option>`
                            ).join('');
                        }
                        
                        controlHtml = `
                            <div class="property-item">
                                <label class="property-label" for="${controlId}">${label}</label>
                                <select class="property-input property-select element-property-control" 
                                        id="${controlId}" 
                                        data-property="${propertyKey}" 
                                        data-element-type="${elementType}">
                                    ${optionsHtml}
                                </select>
                            </div>
                        `;
                        break;
                        
                    case 'checkbox':
                        controlHtml = `
                            <div class="property-item">
                                <label class="property-label">
                                    <input type="checkbox" 
                                           class="property-input element-property-control" 
                                           id="${controlId}" 
                                           data-property="${propertyKey}" 
                                           data-element-type="${elementType}"
                                           ${defaultValue ? 'checked' : ''}>
                                    ${label}
                                </label>
                            </div>
                        `;
                        break;
                        
                    default:
                        controlHtml = `
                            <div class="property-item">
                                <label class="property-label">${label}</label>
                                <input type="text" class="property-input" value="Unsupported type: ${type}" disabled>
                            </div>
                        `;
                }
                
                return controlHtml;
            }
            
            // Method to populate element properties in the properties panel
            populateElementProperties() {
                if (!this.selectedElement || !this.selectedElementData) {
                    return;
                }
                
                const elementType = this.selectedElementData.type;
                const elementPropertiesContent = document.getElementById('element-properties-content');
                
                if (elementPropertiesContent) {
                    // Generate and insert dynamic property controls
                    const propertiesHtml = this.renderElementProperties(elementType);
                    elementPropertiesContent.innerHTML = propertiesHtml;
                    
                    // Setup event listeners for the new controls
                    this.setupElementPropertyEventListeners();
                    
                    // Populate current values from the element (if any stored element data exists)
                    this.populateCurrentPropertyValues();
                }
            }
            
            // Setup event listeners for dynamically created property controls
            setupElementPropertyEventListeners() {
                const propertyControls = document.querySelectorAll('.element-property-control');
                
                propertyControls.forEach(control => {
                    const eventType = control.type === 'color' || control.type === 'range' ? 'input' : 'change';
                    
                    control.addEventListener(eventType, (e) => {
                        const property = e.target.dataset.property;
                        const elementType = e.target.dataset.elementType;
                        const value = e.target.type === 'checkbox' ? e.target.checked : e.target.value;
                        
                        this.updateElementProperty(property, value, elementType);
                        
                        // Sync color input and text input
                        if (e.target.type === 'color') {
                            const textInput = document.getElementById(e.target.id + '-text');
                            if (textInput) {
                                textInput.value = e.target.value;
                            }
                        } else if (e.target.classList.contains('color-text')) {
                            const colorInput = document.getElementById(e.target.id.replace('-text', ''));
                            if (colorInput && this.isValidHexColor(e.target.value)) {
                                colorInput.value = e.target.value;
                            }
                        }
                    });
                });
            }
            
            // Populate current property values from element data
            populateCurrentPropertyValues() {
                if (!this.selectedElement) return;
                
                // This is a placeholder for now - we'll populate actual values
                // when we implement property value storage on elements
                const elementType = this.selectedElementData.type;
                const template = this.elementPropertyTemplates[elementType];
                
                if (!template) return;
                
                // For now, just use default values from template
                // Later we'll extract actual values from the element's stored data
                Object.entries(template).forEach(([propertyKey, config]) => {
                    const controlId = `${elementType}-${propertyKey}`;
                    const control = document.getElementById(controlId);
                    
                    if (control) {
                        if (control.type === 'checkbox') {
                            control.checked = config.defaultValue || false;
                        } else {
                            control.value = config.defaultValue || '';
                        }
                        
                        // Handle color text input sync
                        if (control.type === 'color') {
                            const textControl = document.getElementById(controlId + '-text');
                            if (textControl) {
                                textControl.value = config.defaultValue || '#000000';
                            }
                        }
                    }
                });
            }
            
            // Update element property with real-time visual changes
            updateElementProperty(property, value, elementType) {
                if (!this.selectedElement) return;
                
                // Store the property value in element's dataset
                if (!this.selectedElement.dataset.properties) {
                    this.selectedElement.dataset.properties = '{}';
                }
                
                const currentProperties = JSON.parse(this.selectedElement.dataset.properties);
                currentProperties[property] = value;
                this.selectedElement.dataset.properties = JSON.stringify(currentProperties);
                
                // Apply the property change visually
                this.applyPropertyChange(property, value, elementType);
                
                // Show feedback
                this.showNotification(`Updated ${property}`, 'success');
            }
            
            // Apply property changes to the visual element
            applyPropertyChange(property, value, elementType) {
                if (!this.selectedElement) return;
                
                const element = this.selectedElement;
                
                // Handle common properties that apply to all elements
                switch (property) {
                    case 'backgroundColor':
                    case 'bgColor':
                        element.style.backgroundColor = value;
                        break;
                    case 'borderColor':
                        element.style.borderColor = value;
                        break;
                    case 'borderWidth':
                        element.style.borderWidth = value + 'px';
                        break;
                    case 'borderRadius':
                        element.style.borderRadius = value + 'px';
                        break;
                    case 'padding':
                        element.style.padding = value + 'px';
                        break;
                }
                
                // Handle element-specific properties
                switch (elementType) {
                    case 'header':
                        this.updateHeaderElement(element, property, value);
                        break;
                    case 'text':
                        this.updateTextElement(element, property, value);
                        break;
                    case 'table':
                        this.updateTableElement(element, property, value);
                        break;
                    case 'bar-chart':
                    case 'line-chart':
                    case 'pie-chart':
                        this.updateChartElement(element, property, value, elementType);
                        break;
                    case 'number':
                        this.updateNumberElement(element, property, value);
                        break;
                    case 'progress':
                        this.updateProgressElement(element, property, value);
                        break;
                    case 'metric':
                        this.updateMetricElement(element, property, value);
                        break;
                    case 'image':
                        this.updateImageElement(element, property, value);
                        break;
                    case 'divider':
                        this.updateDividerElement(element, property, value);
                        break;
                }
            }
            
            // Header element property updates
            updateHeaderElement(element, property, value) {
                const headerText = element.querySelector('h2');
                if (!headerText) return;
                
                switch (property) {
                    case 'content':
                        headerText.textContent = value || 'Report Header';
                        break;
                    case 'fontSize':
                        headerText.style.fontSize = value + 'px';
                        break;
                    case 'fontWeight':
                        headerText.style.fontWeight = value;
                        break;
                    case 'textColor':
                        headerText.style.color = value;
                        break;
                    case 'alignment':
                        headerText.style.textAlign = value;
                        break;
                }
            }
            
            // Text element property updates
            updateTextElement(element, property, value) {
                const textElement = element.querySelector('p');
                if (!textElement) return;
                
                switch (property) {
                    case 'content':
                        textElement.textContent = value || 'Sample text content';
                        break;
                    case 'fontSize':
                        textElement.style.fontSize = value + 'px';
                        break;
                    case 'fontWeight':
                        textElement.style.fontWeight = value;
                        break;
                    case 'textColor':
                        textElement.style.color = value;
                        break;
                    case 'alignment':
                        textElement.style.textAlign = value;
                        break;
                }
            }
            
            // Table element property updates
            updateTableElement(element, property, value) {
                const titleElement = element.querySelector('strong');
                const tableContainer = element.querySelector('div:last-child');
                const headerRow = tableContainer?.querySelector('div:first-child');
                
                switch (property) {
                    case 'title':
                        if (titleElement) {
                            titleElement.textContent = value || 'Data Table';
                        }
                        break;
                    case 'showHeaders':
                        if (headerRow) {
                            headerRow.style.display = value ? 'block' : 'none';
                        }
                        break;
                    case 'borderStyle':
                        if (tableContainer) {
                            tableContainer.style.borderStyle = value;
                            const rows = tableContainer.querySelectorAll('div');
                            rows.forEach(row => {
                                if (row !== headerRow) {
                                    row.style.borderTopStyle = value;
                                }
                            });
                        }
                        break;
                    case 'headerBgColor':
                        if (headerRow) {
                            headerRow.style.backgroundColor = value;
                        }
                        break;
                    case 'columns':
                        this.rebuildTableStructure(element, value);
                        break;
                    case 'rows':
                        this.rebuildTableStructure(element, null, value);
                        break;
                }
            }
            
            // Chart element property updates
            updateChartElement(element, property, value, chartType) {
                const titleElement = element.querySelector('strong');
                const chartContainer = element.querySelector('div:last-child');
                
                switch (property) {
                    case 'title':
                        if (titleElement) {
                            titleElement.textContent = value || `${chartType.charAt(0).toUpperCase() + chartType.slice(1).replace('-', ' ')}`;
                        }
                        break;
                    case 'colorScheme':
                        this.updateChartColors(element, value, chartType);
                        break;
                    case 'showLegend':
                        this.toggleChartLegend(element, value, chartType);
                        break;
                    case 'lineColor':
                        if (chartType === 'line-chart') {
                            const polyline = element.querySelector('polyline');
                            if (polyline) {
                                polyline.setAttribute('stroke', value);
                            }
                        }
                        break;
                }
            }
            
            // Number element property updates
            updateNumberElement(element, property, value) {
                const numberSpan = element.querySelector('span:nth-child(2)');
                const labelDiv = element.querySelector('div:last-child');
                
                switch (property) {
                    case 'value':
                        if (numberSpan) {
                            numberSpan.textContent = this.formatNumber(value, element);
                        }
                        break;
                    case 'label':
                        if (labelDiv) {
                            labelDiv.textContent = value || 'Total Count';
                        }
                        break;
                    case 'format':
                        if (numberSpan) {
                            const currentValue = this.getStoredProperty(element, 'value') || 42;
                            numberSpan.textContent = this.formatNumber(currentValue, element, value);
                        }
                        break;
                    case 'fontSize':
                        if (numberSpan) {
                            numberSpan.style.fontSize = value + 'px';
                        }
                        break;
                    case 'valueColor':
                        if (numberSpan) {
                            numberSpan.style.color = value;
                        }
                        break;
                    case 'labelColor':
                        if (labelDiv) {
                            labelDiv.style.color = value;
                        }
                        break;
                }
            }
            
            // Progress element property updates
            updateProgressElement(element, property, value) {
                const titleElement = element.querySelector('strong');
                const progressBar = element.querySelector('div:last-child > div');
                const percentageText = progressBar?.textContent;
                
                switch (property) {
                    case 'title':
                        if (titleElement) {
                            titleElement.textContent = value || 'Progress';
                        }
                        break;
                    case 'value':
                        if (progressBar) {
                            progressBar.style.width = value + '%';
                            const showPercentage = this.getStoredProperty(element, 'showPercentage');
                            if (showPercentage !== false) {
                                progressBar.textContent = value + '%';
                            }
                        }
                        break;
                    case 'showPercentage':
                        if (progressBar) {
                            if (value) {
                                const currentValue = this.getStoredProperty(element, 'value') || 65;
                                progressBar.textContent = currentValue + '%';
                            } else {
                                progressBar.textContent = '';
                            }
                        }
                        break;
                    case 'barColor':
                        if (progressBar) {
                            progressBar.style.backgroundColor = value;
                        }
                        break;
                    case 'backgroundColor':
                        const progressContainer = element.querySelector('div:last-child');
                        if (progressContainer) {
                            progressContainer.style.backgroundColor = value;
                        }
                        break;
                    case 'height':
                        const container = element.querySelector('div:last-child');
                        if (container && progressBar) {
                            container.style.height = value + 'px';
                            progressBar.style.height = '100%';
                        }
                        break;
                }
            }
            
            // Metric element property updates
            updateMetricElement(element, property, value) {
                const changeSpan = element.querySelector('span:nth-child(2)');
                const valueDiv = element.querySelector('div:nth-child(2)');
                const titleDiv = element.querySelector('div:last-child');
                
                switch (property) {
                    case 'title':
                        if (titleDiv) {
                            titleDiv.textContent = value || 'Revenue';
                        }
                        break;
                    case 'value':
                        if (valueDiv) {
                            valueDiv.textContent = value || '$125,430';
                        }
                        break;
                    case 'change':
                        if (changeSpan) {
                            changeSpan.textContent = value || '▲ 12.5%';
                        }
                        break;
                    case 'changeColor':
                        if (changeSpan) {
                            changeSpan.style.color = value;
                        }
                        break;
                    case 'showBorder':
                        const container = element.querySelector('div[style*="border"]');
                        if (container) {
                            container.style.border = value ? '1px solid #ddd' : 'none';
                        }
                        break;
                }
            }
            
            // Image element property updates
            updateImageElement(element, property, value) {
                const imageContainer = element.querySelector('div');
                const placeholderDiv = imageContainer?.querySelector('div');
                
                switch (property) {
                    case 'src':
                        if (value && value.trim()) {
                            // Replace placeholder with actual image
                            imageContainer.innerHTML = `<img src="${value}" alt="${this.getStoredProperty(element, 'alt') || 'Image'}" style="max-width: 100%; height: auto; border-radius: 4px;">`;
                        } else {
                            // Show placeholder
                            const showPlaceholder = this.getStoredProperty(element, 'showPlaceholder');
                            if (showPlaceholder !== false) {
                                imageContainer.innerHTML = `
                                    <div style="border: 2px dashed #ddd; padding: 20px; border-radius: 4px; text-align: center;">
                                        <div style="font-size: 24px; margin-bottom: 4px;">🖼️</div>
                                        <div style="font-size: 12px; color: #666;">Image Placeholder</div>
                                    </div>
                                `;
                            }
                        }
                        break;
                    case 'alt':
                        const img = element.querySelector('img');
                        if (img) {
                            img.alt = value || 'Image';
                        }
                        break;
                    case 'fit':
                        const image = element.querySelector('img');
                        if (image) {
                            image.style.objectFit = value;
                        }
                        break;
                    case 'showPlaceholder':
                        const currentSrc = this.getStoredProperty(element, 'src');
                        if (!currentSrc || !currentSrc.trim()) {
                            if (value) {
                                // Show placeholder
                                this.updateImageElement(element, 'src', '');
                            } else {
                                // Hide placeholder
                                imageContainer.innerHTML = '';
                            }
                        }
                        break;
                }
            }
            
            // Divider element property updates
            updateDividerElement(element, property, value) {
                const leftLine = element.querySelector('div:first-child');
                const rightLine = element.querySelector('div:last-child');
                const container = element;
                
                switch (property) {
                    case 'thickness':
                        if (leftLine && rightLine) {
                            leftLine.style.height = value + 'px';
                            rightLine.style.height = value + 'px';
                        }
                        break;
                    case 'color':
                        if (leftLine && rightLine) {
                            leftLine.style.backgroundColor = value;
                            rightLine.style.backgroundColor = value;
                        }
                        break;
                    case 'style':
                        if (leftLine && rightLine) {
                            const borderStyle = value === 'dashed' ? '2px dashed' : value === 'dotted' ? '2px dotted' : 'solid';
                            if (value !== 'solid') {
                                leftLine.style.border = 'none';
                                rightLine.style.border = 'none';
                                leftLine.style.borderTop = `${this.getStoredProperty(element, 'thickness') || 1}px ${value} ${this.getStoredProperty(element, 'color') || '#dee2e6'}`;
                                rightLine.style.borderTop = `${this.getStoredProperty(element, 'thickness') || 1}px ${value} ${this.getStoredProperty(element, 'color') || '#dee2e6'}`;
                                leftLine.style.height = '0';
                                rightLine.style.height = '0';
                            } else {
                                leftLine.style.border = 'none';
                                rightLine.style.border = 'none';
                                leftLine.style.height = (this.getStoredProperty(element, 'thickness') || 1) + 'px';
                                rightLine.style.height = (this.getStoredProperty(element, 'thickness') || 1) + 'px';
                                leftLine.style.backgroundColor = this.getStoredProperty(element, 'color') || '#dee2e6';
                                rightLine.style.backgroundColor = this.getStoredProperty(element, 'color') || '#dee2e6';
                            }
                        }
                        break;
                    case 'width':
                        container.style.width = value + 'px';
                        break;
                }
            }
            
            // Helper functions
            getStoredProperty(element, property) {
                try {
                    const properties = JSON.parse(element.dataset.properties || '{}');
                    return properties[property];
                } catch (e) {
                    return null;
                }
            }
            
            formatNumber(value, element, format = null) {
                const currentFormat = format || this.getStoredProperty(element, 'format') || 'number';
                const numValue = parseFloat(value) || 0;
                
                switch (currentFormat) {
                    case 'currency':
                        return new Intl.NumberFormat('en-US', { 
                            style: 'currency', 
                            currency: 'USD' 
                        }).format(numValue);
                    case 'percentage':
                        return numValue.toFixed(1) + '%';
                    default:
                        return numValue.toLocaleString();
                }
            }
            
            rebuildTableStructure(element, columns = null, rows = null) {
                // This is a placeholder for table restructuring
                // In a full implementation, you'd rebuild the table HTML structure
                this.showNotification('Table restructuring coming soon!', 'info');
            }
            
            updateChartColors(element, colorScheme, chartType) {
                // This is a placeholder for chart color updates
                // In a full implementation, you'd update chart colors based on the scheme
                this.showNotification(`Updated ${chartType} colors to ${colorScheme}`, 'info');
            }
            
            toggleChartLegend(element, show, chartType) {
                // This is a placeholder for chart legend toggling
                // In a full implementation, you'd show/hide chart legends
                this.showNotification(`Chart legend ${show ? 'shown' : 'hidden'}`, 'info');
            }
            
            // Helper function to validate hex color
            isValidHexColor(hex) {
                return /^#([A-Fa-f0-9]{6}|[A-Fa-f0-9]{3})$/.test(hex);
            }
            
            // Keyboard shortcuts handler
            handleKeyboardShortcuts(e) {
                // Don't handle shortcuts when typing in input fields
                if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') {
                    return;
                }
                
                switch (e.key) {
                    case 'z':
                        if (e.ctrlKey || e.metaKey) {
                            if (e.shiftKey) {
                                // Ctrl+Shift+Z or Cmd+Shift+Z for redo
                                this.performRedo();
                            } else {
                                // Ctrl+Z or Cmd+Z for undo
                                this.performUndo();
                            }
                            e.preventDefault();
                        }
                        break;
                    case 'y':
                        if (e.ctrlKey || e.metaKey) {
                            // Ctrl+Y or Cmd+Y for redo
                            this.performRedo();
                            e.preventDefault();
                        }
                        break;
                    case 'Delete':
                    case 'Backspace':
                        if (this.selectedElement) {
                            this.deleteSelectedElement();
                            e.preventDefault();
                        }
                        break;
                    case 'Escape':
                        this.deselectAllElements();
                        break;
                    case 'c':
                        if (e.ctrlKey || e.metaKey) {
                            this.copySelectedElement();
                            e.preventDefault();
                        }
                        break;
                    case 'v':
                        if (e.ctrlKey || e.metaKey) {
                            this.pasteElement();
                            e.preventDefault();
                        }
                        break;
                    case 'd':
                        if (e.ctrlKey || e.metaKey) {
                            this.duplicateSelectedElement();
                            e.preventDefault();
                        }
                        break;
                    case 's':
                        if (e.ctrlKey || e.metaKey) {
                            this.saveReport();
                            e.preventDefault();
                        }
                        break;
                }
            }
            
            // Delete selected element
            deleteSelectedElement() {
                if (!this.selectedElement) {
                    this.showNotification('No element selected for deletion', 'warning');
                    return;
                }
                
                const canvas = document.querySelector('.report-canvas');
                
                // Create and execute delete element action
                const deleteAction = new DeleteElementAction(this.selectedElement, canvas, this);
                const success = this.actionHistory.executeAction(deleteAction);
                
                if (success) {
                    // Update undo/redo button states
                    this.updateUndoRedoButtons();
                    this.showNotification(`Deleted ${deleteAction.element.dataset.componentType}`, 'success');
                } else {
                    this.showNotification(`Failed to delete element`, 'warning');
                }
            }
            
            // Copy selected element (placeholder for future implementation)
            copySelectedElement() {
                if (!this.selectedElement) {
                    this.showNotification('No element selected for copying', 'warning');
                    return;
                }
                
                // Store element data for pasting
                const elementData = {
                    type: this.selectedElementData.type,
                    properties: this.selectedElement.dataset.properties || '{}',
                    innerHTML: this.selectedElement.innerHTML,
                    style: this.selectedElement.style.cssText
                };
                
                // Store in a simple clipboard simulation
                this.clipboard = elementData;
                
                this.showNotification(`Copied ${elementData.type}`, 'info');
            }
            
            // Paste element (placeholder for future implementation)
            pasteElement() {
                if (!this.clipboard) {
                    this.showNotification('Nothing to paste', 'warning');
                    return;
                }
                
                // Calculate paste position (offset from original)
                const offsetX = 20;
                const offsetY = 20;
                
                // Create new element at offset position
                const newElement = document.createElement('div');
                newElement.className = 'canvas-element';
                newElement.dataset.componentType = this.clipboard.type;
                newElement.innerHTML = this.clipboard.innerHTML;
                
                // Apply stored properties
                if (this.clipboard.properties) {
                    newElement.dataset.properties = this.clipboard.properties;
                }
                
                // Apply style with offset position
                newElement.style.cssText = this.clipboard.style;
                const currentLeft = parseInt(newElement.style.left) || 0;
                const currentTop = parseInt(newElement.style.top) || 0;
                newElement.style.left = (currentLeft + offsetX) + 'px';
                newElement.style.top = (currentTop + offsetY) + 'px';
                
                // Add interactions
                this.setupElementInteractions(newElement);
                
                // Add to canvas
                const canvas = document.querySelector('.report-canvas');
                canvas.appendChild(newElement);
                
                // Update element count
                this.elementCount++;
                this.updateStatusBar();
                
                // Hide empty state
                const emptyState = document.querySelector('.canvas-empty-state');
                if (emptyState) {
                    emptyState.style.display = 'none';
                }
                
                // Select the new element
                this.selectElement(newElement);
                
                this.showNotification(`Pasted ${this.clipboard.type}`, 'success');
            }
            
            // Duplicate selected element
            duplicateSelectedElement() {
                if (!this.selectedElement) {
                    this.showNotification('No element selected for duplication', 'warning');
                    return;
                }
                
                this.copySelectedElement();
                this.pasteElement();
            }
            
            // Setup context menu functionality
            setupContextMenu() {
                const contextMenu = document.getElementById('context-menu');
                const contextMenuItems = contextMenu.querySelectorAll('.context-menu-item');
                
                // Add right-click event to canvas elements
                document.addEventListener('contextmenu', (e) => {
                    const element = e.target.closest('.canvas-element');
                    if (element) {
                        e.preventDefault();
                        
                        // Select the element first
                        this.selectElement(element);
                        
                        // Show context menu
                        this.showContextMenu(e.clientX, e.clientY);
                    }
                });
                
                // Handle context menu item clicks
                contextMenuItems.forEach(item => {
                    item.addEventListener('click', (e) => {
                        const action = item.dataset.action;
                        this.handleContextMenuAction(action);
                        this.hideContextMenu();
                    });
                });
            }
            
            showContextMenu(x, y) {
                const contextMenu = document.getElementById('context-menu');
                const contextMenuItems = contextMenu.querySelectorAll('.context-menu-item');
                
                // Update menu item states
                contextMenuItems.forEach(item => {
                    const action = item.dataset.action;
                    
                    // Disable/enable items based on state
                    if (action === 'copy' || action === 'duplicate' || action === 'delete' || 
                        action === 'bring-to-front' || action === 'send-to-back') {
                        item.classList.toggle('disabled', !this.selectedElement);
                    } else if (action === 'paste') {
                        item.classList.toggle('disabled', !this.clipboard);
                    }
                });
                
                // Position and show menu
                contextMenu.style.left = x + 'px';
                contextMenu.style.top = y + 'px';
                contextMenu.style.display = 'block';
                
                // Adjust position if menu goes off-screen
                const rect = contextMenu.getBoundingClientRect();
                if (rect.right > window.innerWidth) {
                    contextMenu.style.left = (x - rect.width) + 'px';
                }
                if (rect.bottom > window.innerHeight) {
                    contextMenu.style.top = (y - rect.height) + 'px';
                }
            }
            
            hideContextMenu() {
                const contextMenu = document.getElementById('context-menu');
                contextMenu.style.display = 'none';
            }
            
            handleContextMenuAction(action) {
                switch (action) {
                    case 'copy':
                        this.copySelectedElement();
                        break;
                    case 'paste':
                        this.pasteElement();
                        break;
                    case 'duplicate':
                        this.duplicateSelectedElement();
                        break;
                    case 'delete':
                        this.deleteSelectedElement();
                        break;
                    case 'bring-to-front':
                        this.bringElementToFront();
                        break;
                    case 'send-to-back':
                        this.sendElementToBack();
                        break;
                }
            }
            
            bringElementToFront() {
                if (this.selectedElement) {
                    this.selectedElement.style.zIndex = '1000';
                    this.showNotification('Brought element to front', 'info');
                }
            }
            
            sendElementToBack() {
                if (this.selectedElement) {
                    this.selectedElement.style.zIndex = '1';
                    this.showNotification('Sent element to back', 'info');
                }
            }
            
            // Setup selection handles functionality
            setupSelectionHandles() {
                const selectionHandles = document.getElementById('selection-handles');
                const handles = selectionHandles.querySelectorAll('.selection-handle');
                
                let isResizing = false;
                let resizeHandle = null;
                let startX, startY, startWidth, startHeight, startLeft, startTop;
                
                handles.forEach(handle => {
                    handle.addEventListener('mousedown', (e) => {
                        if (!this.selectedElement) return;
                        
                        e.stopPropagation();
                        e.preventDefault();
                        
                        isResizing = true;
                        resizeHandle = handle.classList[1]; // Gets the direction class (nw, ne, etc.)
                        startX = e.clientX;
                        startY = e.clientY;
                        startWidth = this.selectedElement.offsetWidth;
                        startHeight = this.selectedElement.offsetHeight;
                        startLeft = parseInt(this.selectedElement.style.left) || 0;
                        startTop = parseInt(this.selectedElement.style.top) || 0;
                        
                        document.body.style.cursor = handle.style.cursor || getComputedStyle(handle).cursor;
                        this.selectedElement.style.userSelect = 'none';
                        
                        // Disable element dragging during resize
                        this.selectedElement.style.pointerEvents = 'none';
                    });
                });
                
                document.addEventListener('mousemove', (e) => {
                    if (!isResizing || !this.selectedElement) return;
                    
                    const deltaX = e.clientX - startX;
                    const deltaY = e.clientY - startY;
                    
                    let newWidth = startWidth;
                    let newHeight = startHeight;
                    let newLeft = startLeft;
                    let newTop = startTop;
                    
                    // Calculate new dimensions based on handle direction
                    switch (resizeHandle) {
                        case 'se': // Southeast - resize width and height
                            newWidth = Math.max(50, startWidth + deltaX);
                            newHeight = Math.max(30, startHeight + deltaY);
                            break;
                        case 'sw': // Southwest - resize width (left) and height
                            newWidth = Math.max(50, startWidth - deltaX);
                            newHeight = Math.max(30, startHeight + deltaY);
                            newLeft = startLeft + (startWidth - newWidth);
                            break;
                        case 'ne': // Northeast - resize width and height (top)
                            newWidth = Math.max(50, startWidth + deltaX);
                            newHeight = Math.max(30, startHeight - deltaY);
                            newTop = startTop + (startHeight - newHeight);
                            break;
                        case 'nw': // Northwest - resize both dimensions and position
                            newWidth = Math.max(50, startWidth - deltaX);
                            newHeight = Math.max(30, startHeight - deltaY);
                            newLeft = startLeft + (startWidth - newWidth);
                            newTop = startTop + (startHeight - newHeight);
                            break;
                        case 'n': // North - resize height only (top)
                            newHeight = Math.max(30, startHeight - deltaY);
                            newTop = startTop + (startHeight - newHeight);
                            break;
                        case 's': // South - resize height only
                            newHeight = Math.max(30, startHeight + deltaY);
                            break;
                        case 'w': // West - resize width only (left)
                            newWidth = Math.max(50, startWidth - deltaX);
                            newLeft = startLeft + (startWidth - newWidth);
                            break;
                        case 'e': // East - resize width only
                            newWidth = Math.max(50, startWidth + deltaX);
                            break;
                    }
                    
                    // Apply snap to grid if enabled
                    if (this.snapToGrid) {
                        newWidth = Math.round(newWidth / this.gridSize) * this.gridSize;
                        newHeight = Math.round(newHeight / this.gridSize) * this.gridSize;
                        newLeft = Math.round(newLeft / this.gridSize) * this.gridSize;
                        newTop = Math.round(newTop / this.gridSize) * this.gridSize;
                    }
                    
                    // Keep within canvas bounds
                    const canvas = document.querySelector('.report-canvas');
                    const canvasRect = canvas.getBoundingClientRect();
                    const maxWidth = canvasRect.width - newLeft;
                    const maxHeight = canvasRect.height - newTop;
                    
                    newWidth = Math.min(newWidth, maxWidth);
                    newHeight = Math.min(newHeight, maxHeight);
                    newLeft = Math.max(0, Math.min(newLeft, canvasRect.width - newWidth));
                    newTop = Math.max(0, Math.min(newTop, canvasRect.height - newHeight));
                    
                    // Apply the new dimensions and position
                    this.selectedElement.style.width = newWidth + 'px';
                    this.selectedElement.style.height = newHeight + 'px';
                    this.selectedElement.style.left = newLeft + 'px';
                    this.selectedElement.style.top = newTop + 'px';
                    
                    // Update selection handles position
                    this.updateSelectionHandles();
                    
                    // Update position inputs in real-time
                    const elementX = document.getElementById('element-x');
                    const elementY = document.getElementById('element-y');
                    const elementWidth = document.getElementById('element-width');
                    const elementHeight = document.getElementById('element-height');
                    
                    if (elementX) elementX.value = newLeft;
                    if (elementY) elementY.value = newTop;
                    if (elementWidth) elementWidth.value = newWidth;
                    if (elementHeight) elementHeight.value = newHeight;
                });
                
                document.addEventListener('mouseup', () => {
                    if (isResizing) {
                        isResizing = false;
                        resizeHandle = null;
                        document.body.style.cursor = '';
                        
                        if (this.selectedElement) {
                            this.selectedElement.style.userSelect = '';
                            this.selectedElement.style.pointerEvents = '';
                            
                            // Update the selected element data
                            this.selectedElementData.width = this.selectedElement.offsetWidth;
                            this.selectedElementData.height = this.selectedElement.offsetHeight;
                            this.selectedElementData.x = parseInt(this.selectedElement.style.left) || 0;
                            this.selectedElementData.y = parseInt(this.selectedElement.style.top) || 0;
                            
                            this.showNotification('Element resized', 'success');
                        }
                    }
                });
            }
            
            // Update selection handles position and visibility
            updateSelectionHandles() {
                const selectionHandles = document.getElementById('selection-handles');
                
                if (this.selectedElement) {
                    const rect = this.selectedElement.getBoundingClientRect();
                    const canvasContainer = document.querySelector('.canvas-container');
                    const canvasRect = canvasContainer.getBoundingClientRect();
                    const canvas = document.querySelector('.report-canvas');
                    const canvasElementRect = canvas.getBoundingClientRect();
                    
                    // Calculate position relative to canvas container
                    const scaleX = this.currentZoom / 100;
                    const scaleY = this.currentZoom / 100;
                    
                    // Get element's position relative to the scaled canvas
                    const elementLeft = parseInt(this.selectedElement.style.left) || 0;
                    const elementTop = parseInt(this.selectedElement.style.top) || 0;
                    const elementWidth = this.selectedElement.offsetWidth;
                    const elementHeight = this.selectedElement.offsetHeight;
                    
                    // Calculate scaled positions
                    const scaledLeft = canvasElementRect.left - canvasRect.left + canvasContainer.scrollLeft + (elementLeft * scaleX);
                    const scaledTop = canvasElementRect.top - canvasRect.top + canvasContainer.scrollTop + (elementTop * scaleY);
                    const scaledWidth = elementWidth * scaleX;
                    const scaledHeight = elementHeight * scaleY;
                    
                    // Position the selection handles container
                    selectionHandles.style.left = scaledLeft + 'px';
                    selectionHandles.style.top = scaledTop + 'px';
                    selectionHandles.style.width = scaledWidth + 'px';
                    selectionHandles.style.height = scaledHeight + 'px';
                    selectionHandles.style.display = 'block';
                    
                    // Only show handles in design mode
                    if (this.currentView !== 'design') {
                        selectionHandles.style.display = 'none';
                    }
                } else {
                    selectionHandles.style.display = 'none';
                }
            }
            
            // Hide selection handles
            hideSelectionHandles() {
                const selectionHandles = document.getElementById('selection-handles');
                if (selectionHandles) {
                    selectionHandles.style.display = 'none';
                }
            }
            
            // Setup property panel input handlers for position and style properties
            setupPropertyPanelHandlers() {
                // Position property handlers
                const elementX = document.getElementById('element-x');
                const elementY = document.getElementById('element-y');
                const elementWidth = document.getElementById('element-width');
                const elementHeight = document.getElementById('element-height');
                
                if (elementX) {
                    elementX.addEventListener('input', (e) => {
                        if (this.selectedElement) {
                            const newValue = parseInt(e.target.value) || 0;
                            this.selectedElement.style.left = newValue + 'px';
                            this.selectedElementData.x = newValue;
                            this.updateSelectionHandles();
                        }
                    });
                }
                
                if (elementY) {
                    elementY.addEventListener('input', (e) => {
                        if (this.selectedElement) {
                            const newValue = parseInt(e.target.value) || 0;
                            this.selectedElement.style.top = newValue + 'px';
                            this.selectedElementData.y = newValue;
                            this.updateSelectionHandles();
                        }
                    });
                }
                
                if (elementWidth) {
                    elementWidth.addEventListener('input', (e) => {
                        if (this.selectedElement) {
                            const newValue = Math.max(50, parseInt(e.target.value) || 50);
                            this.selectedElement.style.width = newValue + 'px';
                            this.selectedElementData.width = newValue;
                            this.updateSelectionHandles();
                        }
                    });
                }
                
                if (elementHeight) {
                    elementHeight.addEventListener('input', (e) => {
                        if (this.selectedElement) {
                            const newValue = Math.max(30, parseInt(e.target.value) || 30);
                            this.selectedElement.style.height = newValue + 'px';
                            this.selectedElementData.height = newValue;
                            this.updateSelectionHandles();
                        }
                    });
                }
                
                // Style property handlers
                const bgColor = document.getElementById('element-bg-color');
                const bgColorText = document.getElementById('element-bg-color-text');
                const borderColor = document.getElementById('element-border-color');
                const borderColorText = document.getElementById('element-border-color-text');
                const borderWidth = document.getElementById('element-border-width');
                const borderRadius = document.getElementById('element-border-radius');
                const padding = document.getElementById('element-padding');
                
                if (bgColor) {
                    bgColor.addEventListener('input', (e) => {
                        if (this.selectedElement) {
                            this.selectedElement.style.backgroundColor = e.target.value;
                            if (bgColorText) bgColorText.value = e.target.value;
                            this.showNotification('Background color updated', 'success');
                        }
                    });
                }
                
                if (bgColorText) {
                    bgColorText.addEventListener('change', (e) => {
                        if (this.selectedElement && this.isValidHexColor(e.target.value)) {
                            this.selectedElement.style.backgroundColor = e.target.value;
                            if (bgColor) bgColor.value = e.target.value;
                            this.showNotification('Background color updated', 'success');
                        }
                    });
                }
                
                if (borderColor) {
                    borderColor.addEventListener('input', (e) => {
                        if (this.selectedElement) {
                            this.selectedElement.style.borderColor = e.target.value;
                            if (borderColorText) borderColorText.value = e.target.value;
                            this.showNotification('Border color updated', 'success');
                        }
                    });
                }
                
                if (borderColorText) {
                    borderColorText.addEventListener('change', (e) => {
                        if (this.selectedElement && this.isValidHexColor(e.target.value)) {
                            this.selectedElement.style.borderColor = e.target.value;
                            if (borderColor) borderColor.value = e.target.value;
                            this.showNotification('Border color updated', 'success');
                        }
                    });
                }
                
                if (borderWidth) {
                    borderWidth.addEventListener('input', (e) => {
                        if (this.selectedElement) {
                            const newValue = Math.max(0, parseInt(e.target.value) || 0);
                            this.selectedElement.style.borderWidth = newValue + 'px';
                            this.showNotification('Border width updated', 'success');
                        }
                    });
                }
                
                if (borderRadius) {
                    borderRadius.addEventListener('input', (e) => {
                        if (this.selectedElement) {
                            const newValue = Math.max(0, parseInt(e.target.value) || 0);
                            this.selectedElement.style.borderRadius = newValue + 'px';
                            this.showNotification('Border radius updated', 'success');
                        }
                    });
                }
                
                if (padding) {
                    padding.addEventListener('input', (e) => {
                        if (this.selectedElement) {
                            const newValue = Math.max(0, parseInt(e.target.value) || 0);
                            this.selectedElement.style.padding = newValue + 'px';
                            this.showNotification('Padding updated', 'success');
                        }
                    });
                }
            }
            
            // Helper function to convert RGB to hex
            rgbToHex(rgb) {
                if (rgb === 'rgba(0, 0, 0, 0)' || rgb === 'transparent') {
                    return '#ffffff';
                }
                
                const result = rgb.match(/\d+/g);
                if (result) {
                    return '#' + result.map(x => {
                        const hex = parseInt(x).toString(16);
                        return hex.length === 1 ? '0' + hex : hex;
                    }).join('');
                }
                return '#ffffff';
            }
            
            // Inline text editing functionality
            startInlineEditing(element) {
                const elementType = element.dataset.componentType;
                
                // Only allow text editing for header and text elements
                if (elementType !== 'header' && elementType !== 'text') {
                    this.showNotification('Text editing not available for this element type', 'warning');
                    return;
                }
                
                // Find the text element to edit
                let textElement;
                if (elementType === 'header') {
                    textElement = element.querySelector('h2');
                } else if (elementType === 'text') {
                    textElement = element.querySelector('p');
                }
                
                if (!textElement) {
                    this.showNotification('No editable text found in element', 'warning');
                    return;
                }
                
                // Prevent editing if already in edit mode
                if (textElement.isContentEditable) {
                    return;
                }
                
                // Store original text for potential cancellation
                const originalText = textElement.textContent;
                
                // Enable content editing
                textElement.contentEditable = true;
                textElement.classList.add('editing-text');
                
                // Apply editing styles
                textElement.style.outline = '2px solid #007bff';
                textElement.style.outlineOffset = '2px';
                textElement.style.backgroundColor = 'rgba(0, 123, 255, 0.1)';
                textElement.style.borderRadius = '3px';
                textElement.style.padding = '2px 4px';
                
                // Focus and select all text
                textElement.focus();
                
                // Select all text for easy replacement
                if (window.getSelection && document.createRange) {
                    const range = document.createRange();
                    range.selectNodeContents(textElement);
                    const selection = window.getSelection();
                    selection.removeAllRanges();
                    selection.addRange(range);
                }
                
                // Disable element selection and dragging during editing
                element.style.pointerEvents = 'none';
                textElement.style.pointerEvents = 'all';
                
                // Show notification
                this.showNotification('Editing text - Press Enter to save, Escape to cancel', 'info');
                
                // Handle completion events
                const completeEdit = (save = true) => {
                    if (!textElement.isContentEditable) return;
                    
                    let newText = textElement.textContent.trim();
                    
                    if (save && newText) {
                        // Update property panel if content property exists
                        this.updateTextContentInPropertyPanel(elementType, newText);
                        
                        // Store in element properties
                        if (!element.dataset.properties) {
                            element.dataset.properties = '{}';
                        }
                        const currentProperties = JSON.parse(element.dataset.properties);
                        currentProperties.content = newText;
                        element.dataset.properties = JSON.stringify(currentProperties);
                        
                        this.showNotification('Text updated successfully', 'success');
                    } else if (!save) {
                        // Restore original text
                        textElement.textContent = originalText;
                        this.showNotification('Text editing cancelled', 'info');
                    } else if (!newText) {
                        // Don't allow empty text
                        textElement.textContent = originalText;
                        this.showNotification('Text cannot be empty', 'warning');
                    }
                    
                    // Cleanup editing state
                    textElement.contentEditable = false;
                    textElement.classList.remove('editing-text');
                    
                    // Remove editing styles
                    textElement.style.outline = '';
                    textElement.style.outlineOffset = '';
                    textElement.style.backgroundColor = '';
                    textElement.style.borderRadius = '';
                    textElement.style.padding = '';
                    
                    // Re-enable element interactions
                    element.style.pointerEvents = '';
                    textElement.style.pointerEvents = '';
                    
                    // Clear selection
                    if (window.getSelection) {
                        window.getSelection().removeAllRanges();
                    }
                    
                    // Remove event listeners
                    textElement.removeEventListener('keydown', handleKeydown);
                    textElement.removeEventListener('blur', handleBlur);
                };
                
                // Handle keyboard events
                const handleKeydown = (e) => {
                    switch (e.key) {
                        case 'Enter':
                            if (!e.shiftKey) {  // Allow Shift+Enter for line breaks in text blocks
                                e.preventDefault();
                                completeEdit(true);
                            } else if (elementType === 'header') {
                                // Headers don't support line breaks
                                e.preventDefault();
                                completeEdit(true);
                            }
                            break;
                        case 'Escape':
                            e.preventDefault();
                            completeEdit(false);
                            break;
                        case 'Tab':
                            e.preventDefault();
                            completeEdit(true);
                            break;
                    }
                };
                
                // Handle blur (clicking outside)
                const handleBlur = (e) => {
                    // Small delay to allow other click events to process
                    setTimeout(() => {
                        if (textElement.isContentEditable) {
                            completeEdit(true);
                        }
                    }, 100);
                };
                
                // Add event listeners
                textElement.addEventListener('keydown', handleKeydown);
                textElement.addEventListener('blur', handleBlur);
            }
            
            // Update text content in property panel if visible
            updateTextContentInPropertyPanel(elementType, newText) {
                const contentControl = document.getElementById(`${elementType}-content`);
                if (contentControl) {
                    contentControl.value = newText;
                }
            }
            
            showNotification(message, type = 'info') {
                // Remove existing notifications
                const existingNotification = document.querySelector('.notification');
                if (existingNotification) {
                    existingNotification.remove();
                }
                
                const notification = document.createElement('div');
                notification.className = `notification notification-${type}`;
                
                const colors = {
                    success: { bg: '#d4edda', border: '#c3e6cb', text: '#155724' },
                    warning: { bg: '#fff3cd', border: '#ffeaa7', text: '#856404' },
                    info: { bg: '#d1ecf1', border: '#bee5eb', text: '#0c5460' }
                };
                
                const color = colors[type] || colors.info;
                
                notification.style.cssText = `
                    position: fixed;
                    top: 80px;
                    right: 20px;
                    padding: 12px 16px;
                    background: ${color.bg};
                    border: 1px solid ${color.border};
                    color: ${color.text};
                    border-radius: 6px;
                    box-shadow: 0 4px 12px rgba(0,0,0,0.1);
                    z-index: 1001;
                    font-size: 14px;
                    font-weight: 500;
                    max-width: 300px;
                    animation: slideInRight 0.3s ease;
                `;
                
                const icons = {
                    success: '✅',
                    warning: '⚠️',
                    info: 'ℹ️'
                };
                
                notification.innerHTML = `${icons[type] || icons.info} ${message}`;
                document.body.appendChild(notification);
                
                // Auto-remove after 3 seconds
                setTimeout(() => {
                    if (notification.parentNode) {
                        notification.style.animation = 'slideOutRight 0.3s ease forwards';
                        setTimeout(() => notification.remove(), 300);
                    }
                }, 3000);
            }
            
            // Setup image upload functionality for image elements
            setupImageUpload(element) {
                const imageDropZone = element.querySelector('.image-drop-zone');
                const imagePlaceholder = element.querySelector('.image-placeholder');
                const imageUploadFeedback = element.querySelector('.image-upload-feedback');
                
                if (!imageDropZone || !imagePlaceholder) {
                    console.warn('Image upload setup failed: Missing required elements');
                    return;
                }
                
                // File input for click-to-upload functionality
                const fileInput = document.createElement('input');
                fileInput.type = 'file';
                fileInput.accept = 'image/*';
                fileInput.style.display = 'none';
                element.appendChild(fileInput);
                
                // Click to upload functionality
                imagePlaceholder.addEventListener('click', (e) => {
                    e.stopPropagation();
                    fileInput.click();
                });
                
                imagePlaceholder.style.cursor = 'pointer';
                imagePlaceholder.title = 'Click to upload image';
                
                // File input change handler
                fileInput.addEventListener('change', (e) => {
                    const file = e.target.files[0];
                    if (file) {
                        this.handleImageFile(file, element);
                        fileInput.value = ''; // Clear input for next use
                    }
                });
                
                // Prevent default drag behaviors on the element itself to avoid conflicts
                element.addEventListener('dragstart', (e) => {
                    e.preventDefault();
                });
                
                // Drag and drop functionality
                imageDropZone.addEventListener('dragenter', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    
                    // Only proceed if files are being dragged
                    if (e.dataTransfer.types.includes('Files')) {
                        imageDropZone.classList.add('drag-over');
                        this.showNotification('Drop image to upload', 'info');
                    }
                });
                
                imageDropZone.addEventListener('dragover', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    
                    // Only show drag-over effect for files
                    if (e.dataTransfer.types.includes('Files')) {
                        e.dataTransfer.dropEffect = 'copy';
                    }
                });
                
                imageDropZone.addEventListener('dragleave', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    
                    // Only remove drag-over if actually leaving the drop zone
                    if (!imageDropZone.contains(e.relatedTarget)) {
                        imageDropZone.classList.remove('drag-over');
                    }
                });
                
                imageDropZone.addEventListener('drop', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    
                    // Remove drag-over styling
                    imageDropZone.classList.remove('drag-over');
                    
                    // Handle file drop
                    const files = e.dataTransfer.files;
                    if (files.length > 0) {
                        const file = files[0];
                        this.handleImageFile(file, element);
                    }
                });
            }
            
            // Handle image file processing with validation and preview
            handleImageFile(file, element) {
                // File type validation
                if (!this.isValidImageFile(file)) {
                    this.showNotification('Please select a valid image file (JPEG, PNG, GIF, WebP)', 'warning');
                    return;
                }
                
                // File size validation (limit to 10MB)
                const maxSize = 10 * 1024 * 1024; // 10MB in bytes
                if (file.size > maxSize) {
                    this.showNotification('Image file is too large. Please choose a file under 10MB.', 'warning');
                    return;
                }
                
                // Show upload progress feedback
                this.showImageUploadProgress(element, 'Processing image...');
                
                // Use FileReader to convert to base64
                const reader = new FileReader();
                
                reader.onload = (e) => {
                    try {
                        const base64Data = e.target.result;
                        this.displayImageInElement(element, base64Data, file.name);
                        
                        // Store image data in element properties
                        this.storeImageData(element, {
                            src: base64Data,
                            filename: file.name,
                            size: file.size,
                            type: file.type
                        });
                        
                        // Update property panel if this element is selected
                        if (this.selectedElement === element) {
                            this.updateImagePropertyPanel(base64Data, file.name);
                        }
                        
                        this.showNotification(`Image "${file.name}" uploaded successfully`, 'success');
                        
                    } catch (error) {
                        console.error('Error processing image:', error);
                        this.showNotification('Error processing image file', 'warning');
                        this.hideImageUploadProgress(element);
                    }
                };
                
                reader.onerror = () => {
                    console.error('Error reading file:', reader.error);
                    this.showNotification('Error reading image file', 'warning');
                    this.hideImageUploadProgress(element);
                };
                
                // Start reading the file
                reader.readAsDataURL(file);
            }
            
            // Validate image file types
            isValidImageFile(file) {
                const validTypes = [
                    'image/jpeg',
                    'image/jpg', 
                    'image/png',
                    'image/gif',
                    'image/webp',
                    'image/svg+xml',
                    'image/bmp'
                ];
                
                return validTypes.includes(file.type.toLowerCase());
            }
            
            // Show upload progress feedback
            showImageUploadProgress(element, message) {
                const imageDropZone = element.querySelector('.image-drop-zone');
                const feedback = element.querySelector('.image-upload-feedback');
                
                if (feedback) {
                    feedback.textContent = message;
                    feedback.style.opacity = '1';
                    feedback.style.background = 'rgba(0, 123, 255, 0.9)';
                }
                
                if (imageDropZone) {
                    imageDropZone.style.pointerEvents = 'none';
                    imageDropZone.style.opacity = '0.7';
                }
            }
            
            // Hide upload progress feedback
            hideImageUploadProgress(element) {
                const imageDropZone = element.querySelector('.image-drop-zone');
                const feedback = element.querySelector('.image-upload-feedback');
                
                if (feedback) {
                    feedback.style.opacity = '0';
                }
                
                if (imageDropZone) {
                    imageDropZone.style.pointerEvents = '';
                    imageDropZone.style.opacity = '';
                }
            }
            
            // Display uploaded image in the element
            displayImageInElement(element, base64Data, filename) {
                const imageContainer = element.querySelector('.image-drop-zone');
                
                if (!imageContainer) {
                    console.error('Image container not found');
                    return;
                }
                
                // Get current image fit setting
                const imageFit = this.getStoredProperty(element, 'fit') || 'cover';
                
                // Create image HTML
                const imageHTML = `
                    <div class="uploaded-image-container" style="position: relative; width: 100%; height: 100%; min-height: 120px;">
                        <img src="${base64Data}" 
                             alt="${filename}" 
                             style="width: 100%; height: 100%; object-fit: ${imageFit}; border-radius: 4px; cursor: pointer;"
                             title="${filename} - Click to replace">
                        <div class="image-overlay" style="position: absolute; top: 0; left: 0; right: 0; bottom: 0; 
                             background: rgba(0,0,0,0.7); color: white; display: flex; align-items: center; 
                             justify-content: center; opacity: 0; transition: opacity 0.2s ease; border-radius: 4px;
                             font-size: 12px; font-weight: 500; pointer-events: none;">
                            Click to replace
                        </div>
                        <div class="image-upload-feedback">📁 Drop image here</div>
                    </div>
                `;
                
                // Replace placeholder with image
                imageContainer.innerHTML = imageHTML;
                
                // Re-setup upload functionality on the new image
                this.setupImageReplacement(element);
                
                // Add hover effect for image replacement
                const uploadedImage = imageContainer.querySelector('img');
                const imageOverlay = imageContainer.querySelector('.image-overlay');
                
                if (uploadedImage && imageOverlay) {
                    uploadedImage.addEventListener('mouseenter', () => {
                        imageOverlay.style.opacity = '1';
                    });
                    
                    uploadedImage.addEventListener('mouseleave', () => {
                        imageOverlay.style.opacity = '0';
                    });
                }
                
                this.hideImageUploadProgress(element);
            }
            
            // Setup image replacement functionality
            setupImageReplacement(element) {
                const imageContainer = element.querySelector('.image-drop-zone');
                const uploadedImage = imageContainer.querySelector('img');
                
                if (!uploadedImage) return;
                
                // Find or create file input
                let fileInput = element.querySelector('input[type="file"]');
                if (!fileInput) {
                    fileInput = document.createElement('input');
                    fileInput.type = 'file';
                    fileInput.accept = 'image/*';
                    fileInput.style.display = 'none';
                    element.appendChild(fileInput);
                    
                    fileInput.addEventListener('change', (e) => {
                        const file = e.target.files[0];
                        if (file) {
                            this.handleImageFile(file, element);
                            fileInput.value = '';
                        }
                    });
                }
                
                // Click to replace image
                uploadedImage.addEventListener('click', (e) => {
                    e.stopPropagation();
                    fileInput.click();
                });
                
                // Re-setup drag and drop on the image container
                imageContainer.addEventListener('dragenter', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    
                    if (e.dataTransfer.types.includes('Files')) {
                        imageContainer.classList.add('drag-over');
                    }
                });
                
                imageContainer.addEventListener('dragover', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    
                    if (e.dataTransfer.types.includes('Files')) {
                        e.dataTransfer.dropEffect = 'copy';
                    }
                });
                
                imageContainer.addEventListener('dragleave', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    
                    if (!imageContainer.contains(e.relatedTarget)) {
                        imageContainer.classList.remove('drag-over');
                    }
                });
                
                imageContainer.addEventListener('drop', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    
                    imageContainer.classList.remove('drag-over');
                    
                    const files = e.dataTransfer.files;
                    if (files.length > 0) {
                        const file = files[0];
                        this.handleImageFile(file, element);
                    }
                });
            }
            
            // Store image data in element properties
            storeImageData(element, imageData) {
                if (!element.dataset.properties) {
                    element.dataset.properties = '{}';
                }
                
                const currentProperties = JSON.parse(element.dataset.properties);
                
                // Store image-related properties
                currentProperties.src = imageData.src;
                currentProperties.filename = imageData.filename;
                currentProperties.size = imageData.size;
                currentProperties.type = imageData.type;
                currentProperties.uploadDate = new Date().toISOString();
                
                element.dataset.properties = JSON.stringify(currentProperties);
            }
            
            // Update property panel with image data
            updateImagePropertyPanel(base64Data, filename) {
                const srcInput = document.getElementById('image-src');
                const altInput = document.getElementById('image-alt');
                
                if (srcInput) {
                    // Show filename instead of full base64 string for readability
                    srcInput.value = filename || 'Uploaded Image';
                    srcInput.title = 'Image uploaded successfully';
                }
                
                if (altInput && !altInput.value.trim()) {
                    altInput.value = filename || 'Uploaded image';
                }
            }
        }
        
        // Add notification animations and additional styles
        const style = document.createElement('style');
        style.textContent = `
            @keyframes slideInRight {
                from {
                    transform: translateX(100%);
                    opacity: 0;
                }
                to {
                    transform: translateX(0);
                    opacity: 1;
                }
            }
            
            @keyframes slideOutRight {
                from {
                    transform: translateX(0);
                    opacity: 1;
                }
                to {
                    transform: translateX(100%);
                    opacity: 0;
                }
            }
            
            .canvas-legal {
                width: 8.5in;
                height: 14in;
            }
            
            .report-canvas.preview-mode {
                box-shadow: 0 8px 24px rgba(0,0,0,0.2);
            }
            
            .canvas-container {
                scroll-behavior: smooth;
            }
            
            @keyframes shake {
                0%, 100% { transform: translateX(0); }
                10%, 30%, 50%, 70%, 90% { transform: translateX(-2px); }
                20%, 40%, 60%, 80% { transform: translateX(2px); }
            }
            
            @keyframes fadeIn {
                from { opacity: 0; }
                to { opacity: 1; }
            }
            
            @keyframes fadeOut {
                from { opacity: 1; }
                to { opacity: 0; }
            }
        `;
        document.head.appendChild(style);
        
        // Initialize the designer
        let reportDesigner;
        document.addEventListener('DOMContentLoaded', () => {
            reportDesigner = new ReportDesigner();
        });
    </script>
</body>
</html>
